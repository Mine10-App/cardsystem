<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Code Parser & Passenger Approval</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
  :root {
    --gold: #D4AF37;
    --gold-light: #F5E8B8;
    --gold-dark: #B8860B;
    --gold-darker: #8B6914;
    --white: #FFFFFF;
    --gray-light: #F8F8F8;
    --gray: #E5E5E5;
    --gray-dark: #666666;
    --success: #4CAF50;
    --error: #f44336;
    --warning: #ff9800;
    --info: #2196F3;
    --shift-blue: #4b6cb7;
    --shift-blue-dark: #182848;
    --qr-green: #27ae60;
    --qr-green-dark: #219653;
    --delay-orange: #FF9800;
    --delay-orange-dark: #F57C00;
  }
  
  * {
    box-sizing: border-box;
  }
  
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    padding: 80px 20px 20px 20px; /* Increased top padding from 20px to 80px */
    background: var(--white);
    margin: 0;
    color: #333;
    background-color: #f9f9f9;
}
  
  .container {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    max-width: 1600px;
    margin: 0 auto;
  }
  
  .entry-section {
    flex: 1;
    min-width: 280px;
    max-width: 350px;
    background: var(--white);
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 6px 15px rgba(0,0,0,0.08);
    border: 1px solid var(--gold);
    position: relative;
    overflow: hidden;
  }
  
  .entry-section::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 4px;
    background: linear-gradient(90deg, var(--gold), var(--gold-dark));
  }
  
  .entries-section {
    flex: 4;
    min-width: 900px;
    background: var(--white);
    padding: 25px;
    border-radius: 10px;
    box-shadow: 0 6px 15px rgba(0,0,0,0.08);
    border: 1px solid var(--gold);
    overflow-x: auto;
    position: relative;
  }
  
  .entries-section::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 4px;
    background: linear-gradient(90deg, var(--gold), var(--gold-dark));
  }
  
  h2, h3 {
    margin-top: 0;
    color: var(--gold-darker);
    padding-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 10px;
    font-weight: 600;
  }
  
  h2 i, h3 i {
    color: var(--gold);
  }
  
  .form-group {
    margin-bottom: 15px;
  }
  
  label {
    display: block;
    margin-bottom: 6px;
    font-weight: 600;
    font-size: 14px;
    color: var(--gold-darker);
  }
  
  .input-with-icon {
    position: relative;
  }
  
  .input-with-icon i {
    position: absolute;
    left: 12px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--gold);
    z-index: 1;
  }
  
  input, select, textarea { 
    width: 100%; 
    padding: 10px 10px 10px 35px;
    border: 1px solid var(--gold); 
    border-radius: 6px; 
    font-size: 14px; 
    box-sizing: border-box;
    background: var(--white);
    transition: all 0.3s ease;
  }
  
  input:focus, select:focus, textarea:focus {
    outline: none;
    border-color: var(--gold-dark);
    box-shadow: 0 0 0 3px var(--gold-light);
  }
  
  textarea {
    resize: vertical;
    min-height: 60px;
    padding-left: 35px;
  }
  
  table { 
    width: 100%; 
    border-collapse: collapse; 
    margin-top: 10px;
    font-size: 13px;
    border: 1px solid var(--gold);
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
  }
  
  th, td { 
    border: 1px solid var(--gold); 
    padding: 10px; 
    text-align: left; 
    white-space: nowrap;
  }
  
  th {
    background-color: var(--gold-light);
    font-weight: bold;
    color: var(--gold-darker);
    position: sticky;
    top: 0;
  }
  
  tr:nth-child(even) {
    background-color: var(--gray-light);
  }
  
  tr:hover {
    background-color: rgba(212, 175, 55, 0.1);
  }
  
  button.action-btn { 
    width: auto; 
    margin: 0 2px; 
    padding: 8px 14px; 
    font-size: 12px; 
    cursor: pointer; 
    background: var(--gold);
    color: white;
    border: none;
    border-radius: 4px;
    transition: all 0.3s ease;
    display: inline-flex;
    align-items: center;
    gap: 5px;
    font-weight: 500;
  }
  
  button.action-btn:hover {
    background: var(--gold-dark);
    transform: translateY(-2px);
    box-shadow: 0 3px 8px rgba(0,0,0,0.15);
  }
  
  button.action-btn:disabled {
    opacity: 0.6;
    pointer-events: none;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
  }
  
  .button-group {
    display: flex;
    gap: 10px;
    margin-top: 20px;
  }
  
  .button-group button {
    flex: 1;
    padding: 12px;
    font-weight: 600;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
    border-radius: 6px;
    font-size: 14px;
  }
  
  #manualSaveBtn {
    background: var(--gold);
    color: white;
    box-shadow: 0 3px 8px rgba(212, 175, 55, 0.3);
  }
  
  #manualSaveBtn:hover {
    background: var(--gold-dark);
    box-shadow: 0 5px 12px rgba(212, 175, 55, 0.4);
  }
  
  .status-indicator {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 15px;
    padding: 10px;
    background: var(--gold-light);
    border-radius: 6px;
    border-left: 4px solid var(--gold);
  }
  
  .status-indicator i {
    color: var(--gold-dark);
  }
  
  @media (max-width: 1200px) {
    .container {
      flex-direction: column;
    }
    
    .entry-section, .entries-section {
      min-width: 100%;
      max-width: 100%;
    }
  }
  
  .gold-line {
    height: 2px;
    background: linear-gradient(90deg, transparent, var(--gold), transparent);
    margin: 15px 0;
  }
  
  .section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
  }
  
  .entries-count {
    background: var(--gold);
    color: white;
    padding: 6px 14px;
    border-radius: 20px;
    font-size: 13px;
    font-weight: bold;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
  }
  
  .user-shift-container {
    display: flex;
    gap: 20px;
    margin-bottom: 15px;
    justify-content: flex-start;
    align-items: center;
    flex-wrap: wrap;
  }
  
  .user-shift-field {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
  }
  
  .user-shift-field label {
    font-size: 14px;
    margin-bottom: 0;
    color: var(--gold-darker);
    font-weight: 600;
  }
  
  .user-shift-field span {
    background: var(--gold-light);
    padding: 8px 14px;
    border-radius: 6px;
    border: 1px solid var(--gold);
    min-width: 120px;
    display: inline-block;
    font-weight: 500;
    text-align: center;
  }
  
  .clear-notification {
    position: fixed;
    top: 90px; /* Moved down to be below float buttons */
    right: 20px;
    background: var(--success);
    color: white;
    padding: 12px 24px;
    border-radius: 6px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    display: flex;
    align-items: center;
    gap: 10px;
    z-index: 999;
    opacity: 0;
    transform: translateY(-20px);
    transition: all 0.3s ease;
}

.clear-notification.show {
    opacity: 1;
    transform: translateY(0);
}
  
  .shift-status {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 15px;
    padding: 10px;
    background: var(--gray-light);
    border-radius: 6px;
    border-left: 4px solid var(--gold);
  }
  
  .status-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: var(--success);
  }
  
  .status-dot.inactive {
    background: var(--error);
  }
  
  .disabled {
    opacity: 0.6;
    pointer-events: none;
  }
  
  /* Float Navigation - MOVED TO TOP */
.float-nav {
    position: fixed;
    top: 20px;
    right: 30px;
    display: flex;
    flex-direction: row;
    gap: 15px;
    z-index: 1000;
}

.float-btn {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: var(--gold);
    color: white;
    border: none;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.float-btn:hover {
    background: var(--gold-dark);
    transform: translateY(-3px);
    box-shadow: 0 6px 20px rgba(0,0,0,0.3);
}

.float-btn::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255,255,255,0.1);
    opacity: 0;
    transition: opacity 0.3s ease;
}

.float-btn:hover::after {
    opacity: 1;
}

.float-tooltip {
    position: absolute;
    bottom: -40px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 14px;
    white-space: nowrap;
    opacity: 0;
    transition: all 0.3s ease;
    pointer-events: none;
    z-index: 1001;
}

.float-btn:hover .float-tooltip {
    opacity: 1;
    bottom: -35px;
}

/* Individual button colors */
.float-btn:nth-child(1) { background: var(--info); } /* Storage Manager */
.float-btn:nth-child(2) { background: var(--delay-orange); } /* Delay Charge */
.float-btn:nth-child(3) { background: var(--shift-blue); } /* Refresh Shift */
.float-btn:nth-child(4) { background: var(--gold); } /* Home Dashboard */
.float-btn:nth-child(5) { background: var(--gold-dark); } /* Reports */
.float-btn:nth-child(6) { background: var(--qr-green); } /* QR Reports */

/* Responsive adjustments for top placement */
@media (max-width: 768px) {
    .float-nav {
        top: 15px;
        right: 15px;
        gap: 10px;
    }
    
    .float-btn {
        width: 50px;
        height: 50px;
        font-size: 18px;
    }
    
    .float-tooltip {
        font-size: 12px;
        padding: 6px 10px;
        bottom: -35px;
    }
    
    .float-btn:hover .float-tooltip {
        bottom: -30px;
    }
}

@media (max-width: 480px) {
    .float-nav {
        flex-wrap: wrap;
        justify-content: flex-end;
        gap: 8px;
        max-width: 60%;
    }
    
    .float-btn {
        width: 45px;
        height: 45px;
        font-size: 16px;
    }
    
    .float-tooltip {
        font-size: 11px;
        padding: 5px 8px;
        bottom: -30px;
    }
    
    .float-btn:hover .float-tooltip {
        bottom: -25px;
    }
}
  
  @media (max-width: 768px) {
    .float-nav {
      bottom: 20px;
      right: 20px;
    }
    
    .float-btn {
      width: 50px;
      height: 50px;
      font-size: 18px;
    }
    
    .float-tooltip {
      font-size: 12px;
      padding: 6px 10px;
    }
  }

  .scanner-indicator {
    display: none;
    align-items: center;
    gap: 8px;
    margin-top: 8px;
    font-size: 12px;
    color: var(--gold-dark);
  }
  
  .scanner-indicator.show {
    display: flex;
  }
  
  .scanner-dots {
    display: flex;
    gap: 3px;
  }
  
  .scanner-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--gold);
    animation: scanning 0.8s infinite ease-in-out;
  }
  
  .scanner-dot:nth-child(1) { animation-delay: -0.32s; }
  .scanner-dot:nth-child(2) { animation-delay: -0.16s; }
  
  @keyframes scanning {
    0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
    40% { transform: scale(1); opacity: 1; }
  }
  
  .alert-notification {
    position: fixed;
    top: 90px; /* Moved down to be below float buttons */
    left: 50%;
    transform: translateX(-50%) translateY(-20px);
    background: var(--success);
    color: white;
    padding: 12px 24px;
    border-radius: 6px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    display: flex;
    align-items: center;
    gap: 10px;
    z-index: 999;
    opacity: 0;
    transition: all 0.3s ease;
}

.alert-notification.show {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
}
  
  .alert-notification.error {
    background: var(--error);
  }
  
  .alert-notification.warning {
    background: var(--warning);
  }
  
  .alert-notification.info {
    background: var(--info);
  }
  
  .spinner {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid rgba(255,255,255,0.3);
    border-radius: 50%;
    border-top-color: white;
    animation: spin 1s ease-in-out infinite;
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  
  .card-header {
    background: linear-gradient(135deg, var(--gold-light), var(--gold));
    padding: 15px 20px;
    margin: -20px -20px 15px -20px;
    border-radius: 10px 10px 0 0;
    color: var(--gold-darker);
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  
  .fqtv-required {
    background-color: rgba(255, 152, 0, 0.1) !important;
    border-left: 3px solid var(--warning) !important;
  }
  
  .fqtv-warning {
    color: var(--warning);
    font-weight: bold;
    font-style: italic;
  }
  
  .flight-closed {
    background-color: rgba(244, 67, 54, 0.1) !important;
    border-left: 3px solid var(--error) !important;
  }
  
  .flight-closed td {
    opacity: 0.8;
  }
  
  .flight-status-closed {
    color: var(--error);
    font-weight: bold;
    font-size: 0.9em;
    margin-left: 5px;
  }
  
  .flight-closed .action-btn:first-child {
    background: var(--gray) !important;
    color: var(--gray-dark) !important;
    cursor: not-allowed;
    opacity: 0.6;
  }
  
  .flight-closed .action-btn:first-child:hover {
    transform: none !important;
    box-shadow: none !important;
  }
  
  .entry-fields-container {
    margin-top: 10px;
  }
  
  .simple-field-group {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
  }
  
  .simple-field-group .form-group {
    flex: 1;
    margin-bottom: 0;
  }
  
  .entry-card-title {
    text-align: center;
    margin-bottom: 20px;
    color: var(--gold-darker);
    font-size: 18px;
    font-weight: 600;
  }
  
  .no-shift-message {
    text-align: center;
    padding: 10px;
    color: #666;
    font-size: 13px;
  }

  .shift-refresh-btn {
    background: var(--shift-blue);
    color: white;
    border: none;
    border-radius: 5px;
    padding: 8px 16px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
    transition: all 0.3s ease;
  }
  
  .shift-refresh-btn:hover {
    background: var(--shift-blue-dark);
    transform: translateY(-1px);
  }
  
  .shift-refresh-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
  }
  
  /* QR Processing Indicator */
  .qr-processing-indicator {
    display: none;
    align-items: center;
    gap: 8px;
    margin-top: 8px;
    font-size: 12px;
    color: var(--qr-green);
    padding: 5px 10px;
    background: rgba(39, 174, 96, 0.1);
    border-radius: 4px;
    border-left: 3px solid var(--qr-green);
  }
  
  .qr-processing-indicator.show {
    display: flex;
  }
  
  .qr-processing-indicator i {
    color: var(--qr-green);
  }
  
  .qr-success-badge {
    background: var(--qr-green);
    color: white;
    padding: 2px 6px;
    border-radius: 10px;
    font-size: 10px;
    font-weight: bold;
    margin-left: 5px;
  }
  
  .dual-save-btn {
    background: linear-gradient(135deg, var(--gold), var(--qr-green));
    color: white;
  }
  
  .dual-save-btn:hover {
    background: linear-gradient(135deg, var(--gold-dark), var(--qr-green-dark));
  }
  
  /* Delay Charge Styles */
  .delay-charge-btn {
    background: var(--delay-orange);
    color: white;
    border: none;
    border-radius: 5px;
    padding: 8px 16px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
    transition: all 0.3s ease;
  }
  
  .delay-charge-btn:hover {
    background: var(--delay-orange-dark);
    transform: translateY(-2px);
    box-shadow: 0 3px 8px rgba(0,0,0,0.15);
  }
  
  .delay-entry {
    background-color: rgba(255, 152, 0, 0.1) !important;
    border-left: 4px solid var(--delay-orange) !important;
  }
  
  .delay-badge {
    background: var(--delay-orange);
    color: white;
    padding: 2px 6px;
    border-radius: 10px;
    font-size: 10px;
    font-weight: bold;
    margin-left: 5px;
  }
  
  /* Modal Styles */
  .modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
    z-index: 2000;
    justify-content: center;
    align-items: center;
  }
  
  .modal.show {
    display: flex;
  }
  
  .modal-content {
    background: white;
    padding: 30px;
    border-radius: 10px;
    width: 90%;
    max-width: 500px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    border: 2px solid var(--delay-orange);
    position: relative;
  }
  
  .modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 2px solid var(--delay-orange);
  }
  
  .modal-header h3 {
    margin: 0;
    color: var(--delay-orange);
    display: flex;
    align-items: center;
    gap: 10px;
  }
  
  .close-modal {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: var(--delay-orange);
    padding: 5px;
    line-height: 1;
  }
  
  .close-modal:hover {
    color: var(--delay-orange-dark);
  }
  
  .time-input-group {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
  }
  
  .time-input-group .form-group {
    flex: 1;
  }
  
  .delay-calc-result {
    margin-top: 20px;
    padding: 15px;
    background: rgba(255, 152, 0, 0.1);
    border-radius: 6px;
    border-left: 4px solid var(--delay-orange);
  }
  
  .delay-calc-result h4 {
    margin-top: 0;
    margin-bottom: 10px;
    color: var(--delay-orange);
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .delay-calc-details {
    font-size: 14px;
    line-height: 1.5;
  }
  
  .delay-calc-details p {
    margin: 5px 0;
  }
  
  .delay-amount {
    font-weight: bold;
    color: var(--delay-orange-dark);
  }
  
  .no-charge {
    color: var(--success);
    font-weight: bold;
  }
  
  /* Local Storage Tab Styles */
  .local-storage-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.7);
    z-index: 3000;
    justify-content: center;
    align-items: center;
  }
  
  .local-storage-modal.show {
    display: flex;
  }
  
  .local-storage-content {
    background: white;
    padding: 20px;
    border-radius: 10px;
    width: 95%;
    max-width: 1200px;
    max-height: 90vh;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    border: 2px solid var(--gold);
    position: relative;
    display: flex;
    flex-direction: column;
  }
  
  .local-storage-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 2px solid var(--gold);
  }
  
  .local-storage-header h3 {
    margin: 0;
    color: var(--gold-darker);
    display: flex;
    align-items: center;
    gap: 10px;
  }
  
  .close-storage-modal {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: var(--gold);
    padding: 5px;
    line-height: 1;
  }
  
  .close-storage-modal:hover {
    color: var(--gold-dark);
  }
  
  .storage-tabs {
    display: flex;
    gap: 5px;
    margin-bottom: 15px;
    border-bottom: 1px solid var(--gold);
    flex-wrap: wrap;
  }
  
  .storage-tab {
    padding: 10px 20px;
    background: var(--gray-light);
    border: 1px solid var(--gold);
    border-bottom: none;
    border-radius: 6px 6px 0 0;
    cursor: pointer;
    font-weight: 500;
    color: var(--gold-darker);
    transition: all 0.3s ease;
    white-space: nowrap;
  }
  
  .storage-tab:hover {
    background: var(--gold-light);
  }
  
  .storage-tab.active {
    background: var(--gold);
    color: white;
    font-weight: 600;
  }
  
  .storage-tab-content {
    flex: 1;
    overflow: auto;
    margin-bottom: 20px;
  }
  
  .storage-panel {
    display: none;
    padding: 15px;
    background: var(--gray-light);
    border-radius: 6px;
    border: 1px solid var(--gold);
    max-height: 60vh;
    overflow: auto;
  }
  
  .storage-panel.active {
    display: block;
  }
  
  .storage-data-item {
    margin-bottom: 15px;
    padding: 10px;
    background: white;
    border-radius: 4px;
    border-left: 4px solid var(--info);
  }
  
  .storage-data-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }
  
  .storage-key {
    font-weight: bold;
    color: var(--gold-darker);
    font-size: 14px;
  }
  
  .storage-size {
    background: var(--info);
    color: white;
    padding: 3px 8px;
    border-radius: 10px;
    font-size: 11px;
    font-weight: bold;
  }
  
  .storage-value {
    font-family: monospace;
    font-size: 12px;
    white-space: pre-wrap;
    word-break: break-all;
    background: rgba(0,0,0,0.03);
    padding: 8px;
    border-radius: 4px;
    border: 1px solid var(--gray);
    max-height: 200px;
    overflow-y: auto;
  }
  
  .storage-actions {
    display: flex;
    gap: 10px;
    justify-content: flex-end;
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid var(--gold);
  }
  
  .delete-storage-btn {
    background: var(--error);
    color: white;
    border: none;
    border-radius: 5px;
    padding: 10px 20px;
    font-weight: 600;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: all 0.3s ease;
  }
  
  .delete-storage-btn:hover {
    background: #d32f2f;
    transform: translateY(-2px);
    box-shadow: 0 3px 8px rgba(0,0,0,0.15);
  }
  
  .storage-stats {
    display: flex;
    justify-content: space-between;
    margin-bottom: 15px;
    padding: 10px;
    background: var(--gold-light);
    border-radius: 6px;
    font-size: 13px;
  }
  
  .storage-stat-item {
    text-align: center;
    flex: 1;
  }
  
  .storage-stat-value {
    font-size: 18px;
    font-weight: bold;
    color: var(--gold-darker);
  }
  
  .storage-stat-label {
    font-size: 11px;
    color: var(--gray-dark);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  .empty-storage {
    text-align: center;
    padding: 30px;
    color: var(--gray-dark);
    font-style: italic;
  }
  
  .view-json-btn {
    background: var(--info);
    color: white;
    border: none;
    border-radius: 3px;
    padding: 3px 8px;
    font-size: 11px;
    cursor: pointer;
    transition: all 0.3s ease;
  }
  
  .view-json-btn:hover {
    background: #1976d2;
  }
  
  .json-viewer-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.8);
    z-index: 4000;
    justify-content: center;
    align-items: center;
  }
  
  .json-viewer-modal.show {
    display: flex;
  }
  
  .json-viewer-content {
    background: #1e1e1e;
    padding: 20px;
    border-radius: 10px;
    width: 90%;
    max-width: 800px;
    max-height: 90vh;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    position: relative;
  }
  
  .json-viewer-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid #444;
  }
  
  .json-viewer-header h4 {
    margin: 0;
    color: #fff;
    font-family: monospace;
  }
  
  .close-json-viewer {
    background: none;
    border: none;
    font-size: 20px;
    cursor: pointer;
    color: #fff;
    padding: 5px;
  }
  
  .json-viewer-body {
    background: #252525;
    padding: 15px;
    border-radius: 6px;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 13px;
    color: #f8f8f2;
    max-height: 70vh;
    overflow: auto;
    white-space: pre-wrap;
    word-break: break-all;
  }
  
  /* Approved Entries Table Styles */
  .approved-entries-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 15px;
    font-size: 12px;
  }
  
  .approved-entries-table th,
  .approved-entries-table td {
    border: 1px solid var(--gold);
    padding: 8px;
    text-align: left;
  }
  
  .approved-entries-table th {
    background: var(--gold-light);
    font-weight: bold;
    color: var(--gold-darker);
  }
  
  .approved-entries-table tr:nth-child(even) {
    background: var(--gray-light);
  }
  
  .approved-entries-table tr:hover {
    background: rgba(212, 175, 55, 0.1);
  }
  
  /* SQ flight highlight */
  .sq-flight {
    background-color: rgba(0, 123, 255, 0.05) !important;
    border-left: 3px solid var(--info) !important;
  }
  
  .sq-flight td:first-child {
    cursor: pointer;
    position: relative;
  }
  
  .sq-flight td:first-child:hover::after {
    content: "ðŸ”¢ Click to enter number";
    position: absolute;
    right: 5px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 10px;
    color: var(--info);
    background: white;
    padding: 2px 5px;
    border-radius: 3px;
    border: 1px solid var(--info);
    white-space: nowrap;
  }
  
  /* Numeric Keyboard Modal Styles */
  .numeric-keyboard-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.7);
    z-index: 5000;
    justify-content: center;
    align-items: center;
  }
  
  .numeric-keyboard-modal.show {
    display: flex;
  }
  
  .numeric-keyboard-content {
    background: white;
    padding: 25px;
    border-radius: 10px;
    width: 90%;
    max-width: 400px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    border: 2px solid var(--gold);
    position: relative;
  }
  
  .numeric-keyboard-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid var(--gold);
  }
  
  .numeric-keyboard-header h3 {
    margin: 0;
    color: var(--gold-darker);
    font-size: 16px;
  }
  
  .close-numeric-keyboard {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: var(--gold);
    padding: 5px;
  }
  
  .numeric-display {
    margin: 15px 0;
    padding: 15px;
    background: var(--gold-light);
    border-radius: 6px;
    border: 1px solid var(--gold);
    font-size: 24px;
    font-weight: bold;
    text-align: center;
    min-height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow-x: auto;
    white-space: nowrap;
  }
  
  .numeric-keyboard-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-bottom: 15px;
  }
  
  .numeric-key {
    padding: 20px;
    font-size: 18px;
    font-weight: bold;
    background: var(--gray-light);
    border: 2px solid var(--gold);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: center;
    user-select: none;
  }
  
  .numeric-key:hover {
    background: var(--gold-light);
    transform: translateY(-2px);
  }
  
  .numeric-key:active {
    transform: translateY(0);
    background: var(--gold);
    color: white;
  }
  
  .numeric-key-special {
    background: var(--gold);
    color: white;
  }
  
  .numeric-key-special:hover {
    background: var(--gold-dark);
  }
  
  .numeric-keyboard-actions {
    display: flex;
    gap: 10px;
    margin-top: 20px;
  }
  
  .numeric-keyboard-actions button {
    flex: 1;
    padding: 12px;
    font-size: 14px;
    font-weight: 600;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    transition: all 0.3s ease;
  }
  
  #applyNumericBtn {
    background: var(--success);
    color: white;
  }
  
  #applyNumericBtn:hover {
    background: #388e3c;
  }
  
  #clearNumericBtn {
    background: var(--error);
    color: white;
  }
  
  #clearNumericBtn:hover {
    background: #d32f2f;
  }
  
  #closeNumericBtn {
    background: var(--gray);
    color: var(--gray-dark);
  }
  
  #closeNumericBtn:hover {
    background: #ddd;
  }
  
  /* Zoom Modal Styles */
  .zoom-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.85);
    z-index: 6000;
    justify-content: center;
    align-items: center;
  }
  
  .zoom-modal.show {
    display: flex;
  }
  
  .zoom-content {
    background: white;
    padding: 40px;
    border-radius: 15px;
    width: 90%;
    max-width: 600px;
    max-height: 85vh;
    box-shadow: 0 15px 40px rgba(0,0,0,0.4);
    border: 3px solid var(--gold);
    position: relative;
    overflow-y: auto;
    transform: scale(0.95);
    animation: zoomIn 0.3s ease forwards;
  }
  
  @keyframes zoomIn {
    to {
      transform: scale(1);
    }
  }
  
  .zoom-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 30px;
    padding-bottom: 20px;
    border-bottom: 2px solid var(--gold);
  }
  
  .zoom-header h3 {
    margin: 0;
    color: var(--gold-darker);
    font-size: 24px;
    display: flex;
    align-items: center;
    gap: 15px;
  }
  
  .close-zoom {
    background: none;
    border: none;
    font-size: 32px;
    cursor: pointer;
    color: var(--gold);
    padding: 5px;
    line-height: 1;
    transition: all 0.3s ease;
  }
  
  .close-zoom:hover {
    color: var(--gold-dark);
    transform: rotate(90deg);
  }
  
  .zoom-form-group {
    margin-bottom: 25px;
  }
  
  .zoom-form-group label {
    display: block;
    margin-bottom: 10px;
    font-weight: 700;
    font-size: 16px;
    color: var(--gold-darker);
    display: flex;
    align-items: center;
    gap: 10px;
  }
  
  .zoom-input {
    width: 100%;
    padding: 18px 20px 18px 50px;
    border: 2px solid var(--gold);
    border-radius: 10px;
    font-size: 18px;
    background: var(--white);
    transition: all 0.3s ease;
    font-weight: 500;
  }
  
  .zoom-input:focus {
    outline: none;
    border-color: var(--gold-dark);
    box-shadow: 0 0 0 4px var(--gold-light);
  }
  
  .zoom-input-with-icon {
    position: relative;
  }
  
  .zoom-input-with-icon i {
    position: absolute;
    left: 18px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--gold);
    font-size: 20px;
    z-index: 1;
  }
  
  .zoom-textarea {
    resize: vertical;
    min-height: 120px;
    padding-left: 50px;
    line-height: 1.6;
  }
  
  .zoom-select {
    padding: 18px 20px 18px 50px;
    font-size: 18px;
    cursor: pointer;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%23D4AF37' viewBox='0 0 16 16'%3E%3Cpath d='M7.247 11.14L2.451 5.658C1.885 5.013 2.345 4 3.204 4h9.592a1 1 0 0 1 .753 1.659l-4.796 5.48a1 1 0 0 1-1.506 0z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 20px center;
    background-size: 16px;
  }
  
  .zoom-button-group {
    display: flex;
    gap: 20px;
    margin-top: 40px;
    padding-top: 30px;
    border-top: 1px solid var(--gold);
  }
  
  .zoom-button-group button {
    flex: 1;
    padding: 20px;
    font-size: 18px;
    font-weight: 700;
    border-radius: 10px;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
    transition: all 0.3s ease;
  }
  
  #zoomSaveBtn {
    background: linear-gradient(135deg, var(--gold), var(--gold-dark));
    color: white;
  }
  
  #zoomSaveBtn:hover {
    background: linear-gradient(135deg, var(--gold-dark), var(--gold-darker));
    transform: translateY(-3px);
    box-shadow: 0 8px 20px rgba(212, 175, 55, 0.4);
  }
  
  #zoomCancelBtn {
    background: var(--gray);
    color: var(--gray-dark);
  }
  
  #zoomCancelBtn:hover {
    background: #ddd;
    transform: translateY(-2px);
  }
  
  /* Seat-Pax Mismatch Warning */
  .seat-pax-mismatch {
    background-color: rgba(255, 152, 0, 0.15) !important;
    border-left: 4px solid var(--warning) !important;
    animation: pulseWarning 2s infinite;
  }
  
  @keyframes pulseWarning {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.8; }
  }
  
  .seat-pax-warning {
    color: var(--warning);
    font-weight: bold;
    font-size: 0.9em;
    margin-top: 5px;
    display: flex;
    align-items: center;
    gap: 5px;
  }
  
  /* FQTV Zoom Modal */
  .fqtv-zoom-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.85);
    z-index: 7000;
    justify-content: center;
    align-items: center;
  }
  
  .fqtv-zoom-modal.show {
    display: flex;
  }
  
  .fqtv-zoom-content {
    background: white;
    padding: 40px;
    border-radius: 15px;
    width: 90%;
    max-width: 500px;
    box-shadow: 0 15px 40px rgba(0,0,0,0.4);
    border: 3px solid var(--info);
    position: relative;
    transform: scale(0.95);
    animation: zoomIn 0.3s ease forwards;
  }
  
  .fqtv-zoom-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 30px;
    padding-bottom: 20px;
    border-bottom: 2px solid var(--info);
  }
  
  .fqtv-zoom-header h3 {
    margin: 0;
    color: var(--info);
    font-size: 22px;
    display: flex;
    align-items: center;
    gap: 15px;
  }
  
  .close-fqtv-zoom {
    background: none;
    border: none;
    font-size: 28px;
    cursor: pointer;
    color: var(--info);
    padding: 5px;
    line-height: 1;
    transition: all 0.3s ease;
  }
  
  .close-fqtv-zoom:hover {
    color: #1976d2;
    transform: rotate(90deg);
  }
  
  .fqtv-zoom-input {
    width: 100%;
    padding: 20px;
    border: 2px solid var(--info);
    border-radius: 10px;
    font-size: 20px;
    font-weight: 500;
    text-align: center;
    letter-spacing: 1px;
    transition: all 0.3s ease;
  }
  
  .fqtv-zoom-input:focus {
    outline: none;
    border-color: #1976d2;
    box-shadow: 0 0 0 4px rgba(33, 150, 243, 0.2);
  }
  
  .fqtv-zoom-button-group {
    display: flex;
    gap: 15px;
    margin-top: 30px;
  }
  
  .fqtv-zoom-button-group button {
    flex: 1;
    padding: 18px;
    font-size: 16px;
    font-weight: 600;
    border-radius: 10px;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    transition: all 0.3s ease;
  }
  
  #fqtvZoomSaveBtn {
    background: var(--info);
    color: white;
  }
  
  #fqtvZoomSaveBtn:hover {
    background: #1976d2;
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(33, 150, 243, 0.4);
  }
  
  #fqtvZoomCancelBtn {
    background: var(--gray);
    color: var(--gray-dark);
  }
  
  #fqtvZoomCancelBtn:hover {
    background: #ddd;
    transform: translateY(-2px);
  }
  
  /* Manual Entry Button */
  .manual-entry-btn {
    display: none; /* Hide the manual entry button */
  }
  
  /* Auto-zoom indicator for manual fields */
  .auto-zoom-indicator {
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--gold);
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
  }
  
  .input-with-icon:hover .auto-zoom-indicator {
    opacity: 0.7;
  }
  
  /* FQTV field styling for zoom indication */
  .fqtv-field-zoom {
    cursor: pointer;
    position: relative;
  }
  
  .fqtv-field-zoom::after {
    content: 'ðŸ“±';
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 12px;
    opacity: 0;
    transition: opacity 0.3s ease;
  }
  
  .fqtv-field-zoom:hover::after {
    opacity: 0.7;
  }
  
  .editable-cell.fqtv-field-zoom {
    cursor: pointer;
  }
  
  .editable-cell.fqtv-field-zoom:hover {
    background-color: rgba(33, 150, 243, 0.1);
  }
  
  @media (max-width: 768px) {
    .user-shift-container {
      flex-direction: column;
      align-items: flex-start;
      gap: 10px;
    }
    
    .user-shift-field {
      width: 100%;
      justify-content: space-between;
    }
    
    .user-shift-field span {
      min-width: 150px;
      text-align: right;
    }
    
    .time-input-group {
      flex-direction: column;
    }
    
    .modal-content {
      width: 95%;
      padding: 20px;
    }
    
    .local-storage-content {
      width: 98%;
      padding: 15px;
    }
    
    .storage-tabs {
      overflow-x: auto;
      flex-wrap: nowrap;
    }
    
    .storage-tab {
      padding: 8px 12px;
      font-size: 13px;
    }
    
    .storage-stats {
      flex-direction: column;
      gap: 10px;
    }
    
    .storage-stat-item {
      text-align: left;
      display: flex;
      justify-content: space-between;
    }
    
    .approved-entries-table {
      font-size: 11px;
    }
    
    .approved-entries-table th,
    .approved-entries-table td {
      padding: 6px;
    }
    
    .numeric-keyboard-content {
      width: 95%;
      padding: 20px;
    }
    
    .numeric-key {
      padding: 15px;
      font-size: 16px;
    }
    
    .numeric-display {
      font-size: 20px;
      min-height: 50px;
    }
    
    .zoom-content {
      width: 95%;
      padding: 25px;
    }
    
    .zoom-input {
      padding: 15px 15px 15px 45px;
      font-size: 16px;
    }
    
    .zoom-button-group button {
      padding: 15px;
      font-size: 16px;
    }
    
    .fqtv-zoom-content {
      width: 95%;
      padding: 25px;
    }
    
    .fqtv-zoom-input {
      font-size: 18px;
      padding: 15px;
    }
    
    .fqtv-zoom-button-group button {
      padding: 15px;
      font-size: 15px;
    }
  }
</style>
</head>
<body>

<div class="clear-notification" id="clearNotification">
  <i class="fas fa-check-circle"></i>
  <span>Fields cleared for next entry</span>
</div>

<div class="alert-notification" id="alertNotification">
  <i class="fas fa-check-circle"></i>
  <span id="alertMessage">Operation completed successfully</span>
</div>

<!-- Zoom Modal for Manual Entry -->
<div class="zoom-modal" id="zoomModal">
  <div class="zoom-content">
    <div class="zoom-header">
      <h3><i class="fas fa-edit"></i> Manual Passenger Entry</h3>
      <button class="close-zoom" id="closeZoomBtn">&times;</button>
    </div>
    
    <div class="zoom-form-group">
      <label for="zoomNameInput"><i class="fas fa-user"></i> Name</label>
      <div class="zoom-input-with-icon">
        <i class="fas fa-signature"></i>
        <input type="text" id="zoomNameInput" class="zoom-input" placeholder="Enter passenger name" autofocus>
      </div>
    </div>
    
    <div style="display: flex; gap: 20px; margin-bottom: 25px;">
      <div class="zoom-form-group" style="flex: 1;">
        <label for="zoomFlightInput"><i class="fas fa-plane"></i> Flight</label>
        <div class="zoom-input-with-icon">
          <i class="fas fa-plane-departure"></i>
          <input type="text" id="zoomFlightInput" class="zoom-input" placeholder="e.g., EK654">
        </div>
      </div>
      
      <div class="zoom-form-group" style="flex: 1;">
        <label for="zoomAirlineSelect"><i class="fas fa-building"></i> Airline</label>
        <div class="zoom-input-with-icon">
          <i class="fas fa-warehouse"></i>
          <select id="zoomAirlineSelect" class="zoom-input zoom-select">
            <option value="">Select Airline</option>
          </select>
        </div>
      </div>
    </div>
    
    <div style="display: flex; gap: 20px; margin-bottom: 25px;">
      <div class="zoom-form-group" style="flex: 1;">
        <label for="zoomSeatInput"><i class="fas fa-chair"></i> Seat</label>
        <div class="zoom-input-with-icon">
          <i class="fas fa-couch"></i>
          <input type="text" id="zoomSeatInput" class="zoom-input" placeholder="e.g., 12A or 12ABC">
          <div class="seat-pax-warning" id="zoomSeatWarning" style="display: none;">
            <i class="fas fa-exclamation-triangle"></i>
            <span id="zoomSeatWarningText"></span>
          </div>
        </div>
      </div>
      
      <div class="zoom-form-group" style="flex: 1;">
        <label for="zoomPaxInput"><i class="fas fa-users"></i> Number of Pax</label>
        <div class="zoom-input-with-icon">
          <i class="fas fa-user-friends"></i>
          <input type="number" id="zoomPaxInput" class="zoom-input" value="1" min="1">
        </div>
      </div>
    </div>
    
    <div style="display: flex; gap: 20px; margin-bottom: 25px;">
      <div class="zoom-form-group" style="flex: 1;">
        <label for="zoomPnrInput"><i class="fas fa-ticket-alt"></i> PNR</label>
        <div class="zoom-input-with-icon">
          <i class="fas fa-receipt"></i>
          <input type="text" id="zoomPnrInput" class="zoom-input" placeholder="PNR code">
        </div>
      </div>
      
      <div class="zoom-form-group" style="flex: 1;">
        <label for="zoomClassInput"><i class="fas fa-star"></i> Class</label>
        <div class="zoom-input-with-icon">
          <i class="fas fa-star-half-alt"></i>
          <input type="text" id="zoomClassInput" class="zoom-input" placeholder="e.g., Y, J, F">
        </div>
      </div>
    </div>
    
    <div style="display: flex; gap: 20px; margin-bottom: 25px;">
      <div class="zoom-form-group" style="flex: 1;">
        <label for="zoomFqtvInput"><i class="fas fa-id-card"></i> FQTV</label>
        <div class="zoom-input-with-icon">
          <i class="fas fa-address-card"></i>
          <input type="text" id="zoomFqtvInput" class="zoom-input" placeholder="Frequent Flyer Number">
        </div>
      </div>
      
      <div class="zoom-form-group" style="flex: 1;">
        <label for="zoomSerialInput"><i class="fas fa-hashtag"></i> Serial No</label>
        <div class="input-with-icon">
          <i class="fas fa-list-ol"></i>
          <input type="text" id="zoomSerialInput" class="zoom-input" placeholder="Serial number">
        </div>
      </div>
    </div>
    
    <div class="zoom-form-group">
      <label for="zoomRemarksInput"><i class="fas fa-sticky-note"></i> Remarks</label>
      <div class="zoom-input-with-icon">
        <i class="fas fa-comment-alt"></i>
        <textarea id="zoomRemarksInput" class="zoom-input zoom-textarea" placeholder="Additional remarks"></textarea>
      </div>
    </div>
    
    <div class="zoom-button-group">
      <button id="zoomSaveBtn" class="zoom-button">
        <i class="fas fa-save"></i> Save Entry
      </button>
      <button id="zoomCancelBtn" class="zoom-button">
        <i class="fas fa-times"></i> Cancel
      </button>
    </div>
  </div>
</div>

<!-- FQTV Zoom Modal -->
<div class="fqtv-zoom-modal" id="fqtvZoomModal">
  <div class="fqtv-zoom-content">
    <div class="fqtv-zoom-header">
      <h3><i class="fas fa-id-card"></i> Edit FQTV</h3>
      <button class="close-fqtv-zoom" id="closeFqtvZoomBtn">&times;</button>
    </div>
    
    <div class="zoom-form-group">
      <label for="fqtvZoomInput"><i class="fas fa-address-card"></i> Frequent Flyer Number</label>
      <input type="text" id="fqtvZoomInput" class="fqtv-zoom-input" placeholder="Enter FQTV number (e.g., EK123456/Gold)" autofocus>
    </div>
    
    <div class="fqtv-zoom-button-group">
      <button id="fqtvZoomSaveBtn" class="fqtv-zoom-button">
        <i class="fas fa-save"></i> Save
      </button>
      <button id="fqtvZoomCancelBtn" class="fqtv-zoom-button">
        <i class="fas fa-times"></i> Cancel
      </button>
    </div>
  </div>
</div>

<!-- Numeric Keyboard Modal -->
<div class="numeric-keyboard-modal" id="numericKeyboardModal">
  <div class="numeric-keyboard-content">
    <div class="numeric-keyboard-header">
      <h3><i class="fas fa-keyboard"></i> Enter Number for SQ Passenger</h3>
      <button class="close-numeric-keyboard" id="closeNumericKeyboardBtn">&times;</button>
    </div>
    
    <div class="numeric-display" id="numericDisplay">0</div>
    
    <div class="numeric-keyboard-grid">
      <div class="numeric-key" data-value="1">1</div>
      <div class="numeric-key" data-value="2">2</div>
      <div class="numeric-key" data-value="3">3</div>
      <div class="numeric-key" data-value="4">4</div>
      <div class="numeric-key" data-value="5">5</div>
      <div class="numeric-key" data-value="6">6</div>
      <div class="numeric-key" data-value="7">7</div>
      <div class="numeric-key" data-value="8">8</div>
      <div class="numeric-key" data-value="9">9</div>
      <div class="numeric-key" data-value="0">0</div>
      <div class="numeric-key" id="backspaceKey" data-action="backspace"><i class="fas fa-backspace"></i></div>
      <div class="numeric-key" id="clearKey" data-action="clear">C</div>
    </div>
    
    <div class="numeric-keyboard-actions">
      <button id="applyNumericBtn" class="numeric-keyboard-actions-btn">
        <i class="fas fa-check"></i> Apply
      </button>
      <button id="closeNumericBtn" class="numeric-keyboard-actions-btn">
        <i class="fas fa-times"></i> Cancel
      </button>
    </div>
  </div>
</div>

<!-- Local Storage Modal -->
<div class="local-storage-modal" id="localStorageModal">
  <div class="local-storage-content">
    <div class="local-storage-header">
      <h3><i class="fas fa-database"></i> Local Storage Manager</h3>
      <button class="close-storage-modal" id="closeStorageModalBtn">&times;</button>
    </div>
    
    <div class="storage-stats" id="storageStats">
      <!-- Stats will be populated by JavaScript -->
    </div>
    
    <div class="storage-tabs" id="storageTabs">
      <!-- Tabs will be populated by JavaScript -->
    </div>
    
    <div class="storage-tab-content">
      <div class="storage-panel active" id="allStoragePanel">
        <!-- All storage items will be displayed here -->
      </div>
      <!-- Other panels will be created dynamically -->
    </div>
    
    <div class="storage-actions">
      <button id="refreshStorageBtn" class="action-btn">
        <i class="fas fa-sync-alt"></i> Refresh Storage
      </button>
      <button id="clearAllStorageBtn" class="delete-storage-btn">
        <i class="fas fa-trash"></i> Clear All Local Storage
      </button>
    </div>
  </div>
</div>

<!-- JSON Viewer Modal -->
<div class="json-viewer-modal" id="jsonViewerModal">
  <div class="json-viewer-content">
    <div class="json-viewer-header">
      <h4 id="jsonViewerTitle">JSON Viewer</h4>
      <button class="close-json-viewer" id="closeJsonViewerBtn">&times;</button>
    </div>
    <div class="json-viewer-body" id="jsonViewerBody"></div>
  </div>
</div>

<!-- Delay Charge Modal -->
<div class="modal" id="delayChargeModal">
  <div class="modal-content">
    <div class="modal-header">
      <h3><i class="fas fa-clock"></i> Delay Charge Entry</h3>
      <button class="close-modal" id="closeModalBtn">&times;</button>
    </div>
    
    <div class="form-group">
      <label for="delayFlightInput"><i class="fas fa-plane"></i> Flight Number</label>
      <div class="input-with-icon">
        <i class="fas fa-plane-departure"></i>
        <input type="text" id="delayFlightInput" placeholder="Enter flight number (e.g., EK654)">
      </div>
    </div>
    
    <div class="time-input-group">
      <div class="form-group">
        <label for="entryTimeInput"><i class="fas fa-sign-in-alt"></i> Entry Time</label>
        <div class="input-with-icon">
          <i class="fas fa-clock"></i>
          <input type="time" id="entryTimeInput" value="00:00">
        </div>
      </div>
      
      <div class="form-group">
        <label for="exitTimeInput"><i class="fas fa-sign-out-alt"></i> Exit Time</label>
        <div class="input-with-icon">
          <i class="fas fa-clock"></i>
          <input type="time" id="exitTimeInput" value="00:00">
        </div>
      </div>
    </div>
    
    <div class="time-input-group">
      <div class="form-group">
        <label for="stdTimeInput"><i class="fas fa-plane-departure"></i> STD (Departure Time)</label>
        <div class="input-with-icon">
          <i class="fas fa-plane"></i>
          <input type="time" id="stdTimeInput" value="00:00">
        </div>
      </div>
      
      <div class="form-group">
        <label for="delayPaxInput"><i class="fas fa-users"></i> Number of Pax</label>
        <div class="input-with-icon">
          <i class="fas fa-user-friends"></i>
          <input type="number" id="delayPaxInput" value="1" min="1" step="1">
        </div>
      </div>
    </div>
    
    <div id="delayCalcResult" class="delay-calc-result" style="display: none;">
      <h4><i class="fas fa-calculator"></i> Delay Calculation</h4>
      <div id="delayCalcDetails" class="delay-calc-details"></div>
    </div>
    
    <div class="button-group">
      <button id="calculateDelayBtn" class="delay-charge-btn">
        <i class="fas fa-calculator"></i> Calculate Delay
      </button>
      <button id="saveDelayBtn" class="delay-charge-btn" style="background: var(--delay-orange-dark);">
        <i class="fas fa-save"></i> Save Delay Charge
      </button>
    </div>
  </div>
</div>

<div class="float-nav">
  <button id="storageManagerBtn" class="float-btn" style="background: var(--info);">
    <i class="fas fa-database"></i>
    <span class="float-tooltip">Storage Manager</span>
  </button>
  <button id="delayChargeBtn" class="float-btn" style="background: var(--delay-orange);">
    <i class="fas fa-clock"></i>
    <span class="float-tooltip">Delay Charge Entry</span>
  </button>
  <button id="refreshShiftBtn" class="float-btn shift-refresh-float">
    <i class="fas fa-sync-alt"></i>
    <span class="float-tooltip">Refresh Shift</span>
  </button>
  <a href="dash.html" class="float-btn">
    <i class="fas fa-home"></i>
    <span class="float-tooltip">Home Dashboard</span>
  </a>
  <a href="updateCard.html" class="float-btn">
    <i class="fas fa-chart-bar"></i>
    <span class="float-tooltip">Reports</span>
  </a>
  <a href="qrReport.html" class="float-btn" style="background: var(--qr-green);">
    <i class="fas fa-qrcode"></i>
    <span class="float-tooltip">QR Reports</span>
  </a>
</div>

<div class="container">
  <div class="entry-section" id="passengerEntryCard">
    <div class="entry-card-title">
      <i class="fas fa-user-plus"></i> Enter Passenger Details
    </div>
    
    <div class="form-group">
      <label for="codeInput"><i class="fas fa-barcode"></i> Scan Barcode</label>
      <div class="input-with-icon">
        <i class="fas fa-qrcode"></i>
        <input id="codeInput" placeholder="Scan or paste barcode" autocomplete="off" autofocus>
        <div class="auto-zoom-indicator">
          <i class="fas fa-expand-alt"></i>
        </div>
      </div>
      <div class="scanner-indicator" id="scannerIndicator">
        <div class="scanner-dots">
          <div class="scanner-dot"></div>
          <div class="scanner-dot"></div>
          <div class="scanner-dot"></div>
        </div>
        <span>Processing barcode...</span>
      </div>
      <div class="qr-processing-indicator" id="qrProcessingIndicator">
        <i class="fas fa-sync-alt fa-spin"></i>
        <span>Processing QR data...</span>
      </div>
    </div>
    
    <div class="gold-line"></div>
    
    <div class="entry-fields-container">
      <div class="simple-field-group">
        <div class="form-group">
          <label for="nameInput"><i class="fas fa-user"></i> Name</label>
          <div class="input-with-icon">
            <i class="fas fa-signature"></i>
            <input id="nameInput" placeholder="Passenger name" class="auto-zoom-field">
            <div class="auto-zoom-indicator">
              <i class="fas fa-expand-alt"></i>
            </div>
          </div>
        </div>
        
        <div class="form-group">
          <label for="flightInput"><i class="fas fa-plane"></i> Flight</label>
          <div class="input-with-icon">
            <i class="fas fa-plane-departure"></i>
            <input id="flightInput" placeholder="Flight number" class="auto-zoom-field">
            <div class="auto-zoom-indicator">
              <i class="fas fa-expand-alt"></i>
            </div>
          </div>
        </div>
      </div>
      
      <div class="simple-field-group">
        <div class="form-group">
          <label for="pnrInput"><i class="fas fa-ticket-alt"></i> PNR</label>
          <div class="input-with-icon">
            <i class="fas fa-receipt"></i>
            <input id="pnrInput" placeholder="PNR code" class="auto-zoom-field">
            <div class="auto-zoom-indicator">
              <i class="fas fa-expand-alt"></i>
            </div>
          </div>
        </div>
        
        <div class="form-group">
          <label for="seatInput"><i class="fas fa-chair"></i> Seat</label>
          <div class="input-with-icon">
            <i class="fas fa-couch"></i>
            <input id="seatInput" placeholder="Seat number" class="auto-zoom-field">
            <div class="seat-pax-warning" id="seatWarning" style="display: none;">
              <i class="fas fa-exclamation-triangle"></i>
              <span id="seatWarningText"></span>
            </div>
            <div class="auto-zoom-indicator">
              <i class="fas fa-expand-alt"></i>
            </div>
          </div>
        </div>
      </div>
      
      <div class="simple-field-group">
        <div class="form-group">
          <label for="airlineSelect"><i class="fas fa-building"></i> Airline</label>
          <div class="input-with-icon">
            <i class="fas fa-warehouse"></i>
            <select id="airlineSelect"><option value="">Select Airline</option></select>
          </div>
        </div>
        
        <div class="form-group">
          <label for="classInput"><i class="fas fa-star"></i> Class</label>
          <div class="input-with-icon">
            <i class="fas fa-star-half-alt"></i>
            <input id="classInput" placeholder="Class" readonly>
          </div>
        </div>
      </div>
      
      <div class="simple-field-group">
        <div class="form-group">
          <label for="fqtvInput"><i class="fas fa-id-card"></i> FQTV</label>
          <div class="input-with-icon">
            <i class="fas fa-address-card"></i>
            <input id="fqtvInput" placeholder="FQTV" readonly class="fqtv-field-zoom">
          </div>
        </div>
        
        <div class="form-group">
          <label for="numPaxInput"><i class="fas fa-users"></i> Pax</label>
          <div class="input-with-icon">
            <i class="fas fa-user-friends"></i>
            <input id="numPaxInput" placeholder="No of Pax" type="number" value="1" min="1" class="auto-zoom-field">
            <div class="auto-zoom-indicator">
              <i class="fas fa-expand-alt"></i>
            </div>
          </div>
        </div>
      </div>
      
      <div class="form-group">
        <label for="serialInput"><i class="fas fa-hashtag"></i> Serial No</label>
        <div class="input-with-icon">
          <i class="fas fa-list-ol"></i>
          <input id="serialInput" placeholder="Serial number" class="auto-zoom-field">
          <div class="auto-zoom-indicator">
            <i class="fas fa-expand-alt"></i>
          </div>
        </div>
      </div>
      
      <div class="form-group">
        <label for="remarksInput"><i class="fas fa-sticky-note"></i> Remarks</label>
        <div class="input-with-icon">
          <i class="fas fa-comment-alt"></i>
          <textarea id="remarksInput" placeholder="Additional remarks" class="auto-zoom-field"></textarea>
          <div class="auto-zoom-indicator">
            <i class="fas fa-expand-alt"></i>
          </div>
        </div>
      </div>
    </div>
    
    <div class="button-group">
      <button id="manualSaveBtn" class="dual-save-btn">
        <i class="fas fa-save"></i> Save Entry (All Systems)
      </button>
    </div>
    
    <div id="qrStatus" style="font-size: 12px; margin-top: 10px; text-align: center;"></div>
  </div>
  
  <div class="entries-section">
    <div class="section-header">
      <h3><i class="fas fa-list-alt"></i> Saved Entries</h3>
      <div class="entries-count" id="entriesCount">0 entries</div>
    </div>
    
    <div class="user-shift-container">
      <div class="user-shift-field">
        <label>User:</label>
        <span id="userDisplay">Loading...</span>
      </div>
      <div class="user-shift-field">
        <label>Current Shift:</label>
        <span id="shiftDisplay">Loading...</span>
      </div>
      <div class="user-shift-field">
        <label>Shift Date:</label>
        <span id="dateDisplay">-</span>
      </div>
    </div>
    
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Flight</th>
          <th>Seat</th>
          <th>Class</th>
          <th>FQTV</th>
          <th>Pax</th>
          <th>Serial</th>
          <th>Remarks</th>
          <th>PNR</th>
          <th>Date</th>
          <th>Shift</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody id="entriesList"></tbody>
    </table>
  </div>
</div>

<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
<script src="./firebackup.js"></script>
<script src="./fireC1.js"></script>
<!-- Shift System Firebase Configuration -->
<script src="./fireshift.js"></script>
<!-- QR Firebase Configuration -->
<script src="./qr-firebase-config.js"></script>
<script>
// ----- Airlines dropdown -----
// ----- Airlines dropdown -----
const airlines = {
    'EK':'Emirates','FZ':'Flydubai','BA':'British Airways','EY':'Etihad',
    'MH':'Malaysia Airlines','AI':'Air India','AZ':'ITA Airways','VS':'Virgin Atlantic',
    'PG':'Bangkok Airways','GF':'Gulf Air','Q2':'Maldivian','UL':'Srilankan Airlines',
    'AK':'Air Asia','SQ':'Singapore Airlines','6E':'Indigo','OS':'Austrian Airlines',
    '8D':'Fits Air','SU':'Aeroflot','OD':'Batik Air','TK':'Turkish Airline',
    'G9':'Air Arabia','SV':'Saudia','MU':'China Eastern Airlines','BS':'US-Bangla Airlines',
    '3U':'Sichuan Airlines','A1': 'Avia Maldives', 'DR': 'DER Turistic Service AG', 'HP':'Hotel Plan', 'HU':'Humming Bird',
    'KU':'Kouni UK', 'NT' : 'Nanto Tours','MT':'Maldives Travel Factory', 'WI':'Wako International', 'KC':'Air Astana','HIS':'Japan HIS Tours',
    'JD':'Capital Airlines', 'J2':'Azerbaijan Airlines', 'VO':'Voyages Maldives', 'WK':'Edelweiss','DE':'Condor','NO':'Neos','4Y':'Discover Airlines',
    // Add more airlines for FQTV detection
    'JL':'Japan Airlines', 'QF':'Qantas Airways', 'CX':'Cathay Pacific', 'AA':'American Airlines',
    'LA':'LATAM Airlines', 'AY':'Finnair', 'IB':'Iberia', 'QR':'Qatar Airways',
    // Added for better FQTV detection
    'LX':'Swiss International Air Lines', 'LH':'Lufthansa', 'AC':'Air Canada', 'NH':'All Nippon Airways',
    'BR':'EVA Air', 'CI':'China Airlines', 'NZ':'Air New Zealand', 'VA':'Virgin Australia',
    'AF':'Air France', 'KL':'KLM', 'DL':'Delta Air Lines', 'UA':'United Airlines',
    'B6':'JetBlue', 'WN':'Southwest Airlines', 'WS':'WestJet', 'AS':'Alaska Airlines',
    'F9':'Frontier Airlines', 'G4':'Allegiant Air', 'NK':'Spirit Airlines', 'SY':'Sun Country Airlines',
    '9W':'Jet Airways', 'ET':'Ethiopian Airlines', 'KE':'Korean Air', 'OZ':'Asiana Airlines',
    'PR':'Philippine Airlines', 'TG':'Thai Airways'
};

// ----- QR System Storage -----
let qrEntriesProcessed = [];

// ----- Track last values for seat/pax alerts -----
let lastSeatValue = '';
let lastPaxValue = '1';

// ----- NEW: Auto-correct seat format (remove slashes and combine) -----
function autoCorrectSeatFormat(seatNumber) {
    if (!seatNumber || seatNumber.trim() === '') return '';
    
    const seat = seatNumber.toUpperCase().trim();
    
    // Remove spaces and special characters, keep only letters, numbers, and forward slashes
    const cleaned = seat.replace(/[^A-Z0-9\/]/g, '');
    
    // If no slash found, return as is
    if (!cleaned.includes('/')) {
        return cleaned;
    }
    
    // Split by slash and process each part
    const parts = cleaned.split('/').filter(part => part.trim() !== '');
    const correctedSeats = [];
    
    parts.forEach(part => {
        // Extract numbers and letters
        const match = part.match(/^(\d+)([A-Z]*)$/);
        if (match) {
            const rowNumber = match[1];
            const seatLetters = match[2];
            correctedSeats.push(rowNumber + seatLetters);
        } else {
            correctedSeats.push(part);
        }
    });
    
    // Join without slashes (e.g., "3A4B")
    return correctedSeats.join('');
}

// ----- Calculate Pax from Seat Number (IMPROVED) -----
function calculatePaxFromSeatNumber(seatNumber) {
    if (!seatNumber || seatNumber.trim() === '') return 1;
    
    // First auto-correct the seat format
    const correctedSeat = autoCorrectSeatFormat(seatNumber);
    
    // Check for multiple seats (now without slashes, like "3A4B")
    if (/(\d+[A-Z]+){2,}/.test(correctedSeat)) {
        // Pattern for seat groups like "3A4B" or "12ABC15DEF"
        const seatGroups = correctedSeat.match(/\d+[A-Z]+/g);
        if (seatGroups) {
            let totalPax = 0;
            seatGroups.forEach(group => {
                const match = group.match(/^(\d+)([A-Z]+)$/);
                if (match) {
                    totalPax += match[2].length; // Count letters
                }
            });
            return totalPax > 0 ? totalPax : 1;
        }
    }
    
    // Single seat or combined format
    const match = correctedSeat.match(/^(\d+)([A-Z]*)$/);
    if (match) {
        const seatLetters = match[2];
        if (seatLetters.length > 0) {
            return seatLetters.length; // Each letter is a separate seat
        } else {
            return 1; // Just a number, single seat
        }
    }
    
    return 1; // Default
}

// ----- Validate Seat-Pax Match -----
function validateSeatPaxMatch(seatNumber, paxCount) {
    const correctedSeat = autoCorrectSeatFormat(seatNumber);
    const calculatedPax = calculatePaxFromSeatNumber(correctedSeat);
    
    if (calculatedPax !== paxCount) {
        return {
            isValid: false,
            message: `Seat ${seatNumber} (corrected to ${correctedSeat}) indicates ${calculatedPax} passenger(s), but ${paxCount} was entered. Please adjust.`,
            calculatedPax: calculatedPax
        };
    }
    
    return {
        isValid: true,
        message: '',
        calculatedPax: calculatedPax
    };
}

// ----- Validate Pax for Special Airlines -----
function isPaxRestrictedAirline(flightNumber) {
    if (!flightNumber) return false;
    
    const restrictedAirlines = ['FZ', 'SQ', 'EY', 'QR', 'BA', 'MH', 'DE', 'GF', 'EK', 'VS', 'MU', 'HK'];
    const airlineCode = flightNumber.substring(0, 2).toUpperCase();
    
    return restrictedAirlines.includes(airlineCode);
}

// ----- Validate Pax Count -----
function validatePaxCount(flightNumber, seatNumber, enteredPax) {
    if (!flightNumber || !seatNumber) return { isValid: true };
    
    // First check restricted airlines
    const isRestricted = isPaxRestrictedAirline(flightNumber);
    
    if (isRestricted && enteredPax !== 1) {
        return {
            isValid: false,
            message: `Flight ${flightNumber} (${flightNumber.substring(0, 2)}) allows only 1 passenger per seat`
        };
    }
    
    // Then check seat-pax match for non-restricted airlines
    if (!isRestricted) {
        const seatPaxValidation = validateSeatPaxMatch(seatNumber, enteredPax);
        if (!seatPaxValidation.isValid) {
            return seatPaxValidation;
        }
    }
    
    return { isValid: true };
}

// ----- FIXED: Enhanced FQTV extraction from code with multiple patterns -----
function extractFqtvFromQRCode(codeValue, flightNumber = '') {
    const codeUpper = codeValue.toUpperCase();
    let fqtv = '';
    let tier = '';
    let fqtvAirlineCode = '';
    
    console.log("ðŸ” Extracting FQTV from code:", codeUpper);
    console.log("ðŸ“Š Flight airline:", flightNumber ? flightNumber.substring(0, 2).toUpperCase() : '');
    
    // Try multiple patterns to extract FQTV with tier
    const patterns = [
        // Pattern: JL 408435355 N2 (with spaces and trailing N2)
        /([A-Z]{2})\s+(\d+)\s+(N[0-3])\s*$/i,
        // Pattern: JL408435355N2 (without spaces)
        /([A-Z]{2})(\d+)(N[0-3])\s*$/i,
        // Pattern: QR 410865662 N2 (with spaces in middle)
        /([A-Z]{2})\s+(\d+)\s+(N[0-3])/i,
        // Pattern: JL 408435355           N2 (multiple spaces)
        /([A-Z]{2})\s+(\d+)\s+(N[0-3])/i,
        // Pattern with trailing spaces and N0-N3
        /([A-Z]{2})\s*(\d+)\s*(N[0-3])/i
    ];
    
    for (let pattern of patterns) {
        const match = codeUpper.match(pattern);
        if (match) {
            fqtv = `${match[1]} ${match[2]}`;
            tier = match[3].toUpperCase();
            fqtvAirlineCode = match[1];
            console.log("âœ… Found FQTV pattern:", { fqtv, tier, fqtvAirlineCode, pattern: pattern.toString() });
            break;
        }
    }
    
    // If no pattern found with tier, try to extract just airline + number
    if (!fqtv) {
        // Look for airline code followed by number anywhere in string
        const words = codeUpper.split(/\s+/);
        
        for (let i = 0; i < words.length; i++) {
            // Check if word is exactly 2 letters (airline code)
            if (words[i].length === 2 && /^[A-Z]{2}$/.test(words[i])) {
                const airlineCode = words[i];
                
                // Check next word for number
                if (i + 1 < words.length && /^\d+$/.test(words[i + 1])) {
                    fqtv = `${airlineCode} ${words[i + 1]}`;
                    fqtvAirlineCode = airlineCode;
                    
                    // Check for tier in nearby words
                    for (let j = i + 2; j < Math.min(i + 5, words.length); j++) {
                        if (words[j].match(/^N[0-3]$/i)) {
                            tier = words[j].toUpperCase();
                            break;
                        }
                    }
                    console.log("âœ… Found FQTV by scanning words:", { fqtv, tier, fqtvAirlineCode });
                    break;
                }
            }
        }
    }
    
    // Handle N0 case - if tier is N0, return empty string
    if (tier && tier.toUpperCase() === 'N0') {
        console.log("âš ï¸ N0 tier detected, returning empty FQTV");
        return '';
    }
    
    // Format FQTV with correct tier based on airline relationship
    if (fqtv && tier) {
        const result = formatFqtvWithTier(`${fqtv}/${tier}`, flightNumber);
        console.log("ðŸŽ¯ Final FQTV result:", result);
        return result;
    } else if (fqtv) {
        console.log("â„¹ï¸ FQTV without tier:", fqtv);
        return fqtv;
    }
    
    return '';
}

// ----- FIXED: Process FQTV Tier Level with proper airline matching -----
function processFqtvTierWithAirline(fqtvNumber, flightNumber) {
    if (!fqtvNumber || fqtvNumber.trim() === '') return '';
    
    const fqtvUpper = fqtvNumber.toUpperCase();
    const flightUpper = flightNumber ? flightNumber.toUpperCase() : '';
    const isQRFlight = flightUpper.startsWith('QR');
    
    console.log("ðŸ” Processing FQTV tier:", fqtvNumber, "Flight:", flightNumber, "Is QR:", isQRFlight);
    
    // Extract FQTV airline code from FQTV number (first 2 letters)
    let fqtvAirlineCode = '';
    const fqtvMatch = fqtvUpper.match(/^([A-Z]{2})\s*\d+/);
    if (fqtvMatch) {
        fqtvAirlineCode = fqtvMatch[1];
    } else {
        // Try to extract from the format like "JL 408435355"
        const words = fqtvUpper.split(/\s+/);
        if (words.length >= 2 && words[0].length === 2 && /^[A-Z]{2}$/.test(words[0])) {
            fqtvAirlineCode = words[0];
        }
    }
    
    // Extract flight airline code
    const flightAirlineCode = flightUpper.slice(0, 2);
    
    console.log("ðŸ“Š Airline Codes:", {
        fqtvAirline: fqtvAirlineCode,
        flightAirline: flightAirlineCode,
        sameAirline: fqtvAirlineCode && flightAirlineCode && fqtvAirlineCode === flightAirlineCode
    });
    
    // Extract tier from FQTV string
    let tier = '';
    const tierMatch = fqtvUpper.match(/\/(N[0-3]|P|G|S|PLATINUM|GOLD|SILVER|EMERALD|SAPPHIRE|RUBY)$/i);
    if (tierMatch) {
        tier = tierMatch[1].toUpperCase();
    } else {
        // Look for N1/N2/N3/N0 at the end of the string or as separate word
        const words = fqtvUpper.split(/\s+/);
        const lastWord = words[words.length - 1];
        if (lastWord.match(/^N[0-3]$/)) {
            tier = lastWord;
        }
        // Also check second last word
        else if (words.length >= 2) {
            const secondLastWord = words[words.length - 2];
            if (secondLastWord.match(/^N[0-3]$/)) {
                tier = secondLastWord;
            }
        }
    }
    
    console.log("ðŸŽ¯ Extracted tier:", tier);
    
    // Handle N0 tier - no FQTV
    if (tier === 'N0') {
        console.log("âš ï¸ N0 tier detected - no FQTV");
        return '';
    }
    
    // Determine tier mapping based on airline relationship
    let tierDisplay = '';
    
    if (isQRFlight) {
        // QR flights: always use P/G/S
        switch(tier) {
            case 'N1':
            case 'PLATINUM':
            case 'EMERALD':
            case 'P':
                tierDisplay = 'P';
                break;
            case 'N2':
            case 'GOLD':
            case 'SAPPHIRE':
            case 'G':
                tierDisplay = 'G';
                break;
            case 'N3':
            case 'SILVER':
            case 'RUBY':
            case 'S':
                tierDisplay = 'S';
                break;
            default:
                tierDisplay = tier;
        }
        console.log("âœ… QR flight tier display:", tierDisplay);
    } else {
        // Non-QR flights: check airline relationship
        const isSameAirline = fqtvAirlineCode && flightAirlineCode && 
                             fqtvAirlineCode === flightAirlineCode;
        
        if (isSameAirline) {
            // Same airline (not QR): use Platinum/Gold/Silver
            switch(tier) {
                case 'N1':
                case 'P':
                case 'PLATINUM':
                case 'EMERALD':
                    tierDisplay = 'Platinum';
                    break;
                case 'N2':
                case 'G':
                case 'GOLD':
                case 'SAPPHIRE':
                    tierDisplay = 'Gold';
                    break;
                case 'N3':
                case 'S':
                case 'SILVER':
                case 'RUBY':
                    tierDisplay = 'Silver';
                    break;
                default:
                    tierDisplay = tier;
            }
            console.log("âœ… Same airline tier display:", tierDisplay);
        } else {
            // Different airline: use Emerald/Sapphire/Ruby
            switch(tier) {
                case 'N1':
                case 'P':
                case 'PLATINUM':
                    tierDisplay = 'Emerald';
                    break;
                case 'N2':
                case 'G':
                case 'GOLD':
                    tierDisplay = 'Sapphire';
                    break;
                case 'N3':
                case 'S':
                case 'SILVER':
                    tierDisplay = 'Ruby';
                    break;
                default:
                    tierDisplay = tier;
            }
            console.log("âœ… Different airline tier display:", tierDisplay);
        }
    }
    
    return tierDisplay;
}

// ----- FIXED: Format FQTV with correct tier -----
function formatFqtvWithTier(fqtvNumber, flightNumber) {
    if (!fqtvNumber || fqtvNumber.trim() === '') return '';
    
    // Extract the base FQTV (airline + number) without any existing tier
    let cleanFqtv = fqtvNumber;
    
    // Remove any existing tier suffix at the end
    cleanFqtv = cleanFqtv.replace(/\s*\/(N[0-3]|P|G|S|Platinum|Gold|Silver|Emerald|Sapphire|Ruby)\s*$/i, '');
    
    // Also remove N0-N3 as separate words at the end
    cleanFqtv = cleanFqtv.replace(/\s+(N[0-3])\s*$/i, '');
    
    cleanFqtv = cleanFqtv.trim();
    
    // Get the proper tier for this FQTV/flight combination
    const tier = processFqtvTierWithAirline(fqtvNumber, flightNumber);
    
    if (!tier || tier === '') {
        return cleanFqtv;
    }
    
    return `${cleanFqtv}/${tier}`;
}

// ----- Validate Seat for Restricted Airlines -----
function validateAndFixSeatForRestrictedAirline(flightNumber, seatValue) {
    if (!flightNumber || !seatValue) return seatValue;
    
    const restrictedAirlines = ['FZ', 'SQ', 'EY', 'QR', 'BA', 'MH', 'DE', 'GF', 'EK', 'VS', 'MU', 'HK'];
    const airlineCode = flightNumber.substring(0, 2).toUpperCase();
    
    if (restrictedAirlines.includes(airlineCode)) {
        // First auto-correct the seat format
        let correctedSeat = autoCorrectSeatFormat(seatValue);
        
        // For restricted airlines, take only the first seat
        if (correctedSeat) {
            // Extract first seat group (e.g., from "3A4B" take "3A")
            const firstSeatMatch = correctedSeat.match(/^(\d+)([A-Z]*)/);
            if (firstSeatMatch) {
                const rowNumber = firstSeatMatch[1];
                const seatLetters = firstSeatMatch[2];
                // Take only the first seat letter
                if (seatLetters.length > 0) {
                    correctedSeat = rowNumber + seatLetters.charAt(0);
                } else {
                    correctedSeat = rowNumber; // Just row number, no letter
                }
            }
        }
        
        return correctedSeat;
    }
    
    // For non-restricted airlines, just auto-correct the format
    return autoCorrectSeatFormat(seatValue);
}

// ----- Auto-correct Seat for Restricted Airlines -----
function autoCorrectSeatForRestrictedAirline(flightNumber, seatValue) {
    const correctedSeat = validateAndFixSeatForRestrictedAirline(flightNumber, seatValue);
    
    // If seat was corrected, show alert
    if (correctedSeat !== seatValue && correctedSeat) {
        showAlert(`Seat auto-corrected from "${seatValue}" to "${correctedSeat}" for restricted airline ${flightNumber.substring(0, 2)}`, false, true);
    }
    
    return correctedSeat;
}

// ----- Parse code -----
function parseCode(){
    const code = codeInput.value.trim().toUpperCase();
    if(!code) return;
    const parts = code.split(/\s+/);

    const idxMLE = code.indexOf('MLE');
    let name='', pnr='';
    if(idxMLE!==-1){
        let fullNamePart = code.substring(0,idxMLE).trim();
        if(fullNamePart.length>8){
            name = fullNamePart.substring(2, fullNamePart.length-7).trim();
            pnr = fullNamePart.substring(fullNamePart.length-7).trim();
        }
    }

    let flightNo=''; let flightTokenIndex=-1;
    for(let i=0;i<parts.length;i++){
        if(parts[i].includes('MLE')){
            flightTokenIndex=i;
            const mleToken = parts[i];
            flightNo = mleToken.slice(-2) + (parts[i+1]||'').slice(0,4);
            break;
        }
    }

    if(flightNo.length>=2){
        const iata = flightNo.slice(0,2);
        airlineSelect.value = airlines[iata]?iata:'';
    } else airlineSelect.value='';

    let seatNo='';
    let seatClass='';
    if(flightTokenIndex!==-1 && parts[flightTokenIndex+2]){
        let seatToken = parts[flightTokenIndex+2];
        if(seatToken.length>9){
            if (seatToken.length >= 4) {
                seatClass = seatToken.charAt(3);
            }
            
            if (seatToken.length >= 8) {
                const rowPart = seatToken.substring(4, 7);
                const seatLetter = seatToken.charAt(7);
                const rowNumber = parseInt(rowPart, 10).toString();
                seatNo = rowNumber + seatLetter;
            }
        }
    }

    // Use the new FQTV extraction function
    const fqtvResult = extractFqtvFromQRCode(code, flightNo);

    // SPECIAL HANDLING FOR SQ FLIGHTS
    if (flightNo.startsWith('SQ')) {
        seatNo = '';
        pnr = '';
    }

    nameInput.value = name;
    pnrInput.value = pnr;
    flightInput.value = flightNo;
    
    // Auto-correct seat format (remove slashes) and handle restricted airlines
    if (seatNo) {
        seatNo = autoCorrectSeatForRestrictedAirline(flightNo, seatNo);
    }
    
    seatInput.value = seatNo;
    classInput.value = seatClass;
    fqtvInput.value = fqtvResult;
    serialInput.value = '';
    remarksInput.value = '';
    
    // Auto-calculate pax based on seat
    if (seatNo) {
        const calculatedPax = calculatePaxFromSeatNumber(seatNo);
        
        if (isPaxRestrictedAirline(flightNo)) {
            // Restricted airline - always 1 pax
            numPaxInput.value = '1';
            showAlert(`Flight ${flightNo} (${flightNo.substring(0, 2)}) allows only 1 passenger per seat`, false, true);
        } else {
            // Auto-calculate for non-restricted airlines
            numPaxInput.value = calculatedPax;
            if (calculatedPax > 1) {
                showAlert(`Pax auto-calculated as ${calculatedPax} based on seat ${seatNo}`, false, false, true);
            }
        }
    } else {
        numPaxInput.value = '1';
    }
    
    // Check seat-pax match
    checkSeatPaxMatch();
}

// ----- Initialize Airline Dropdown -----
const airlineSelect = document.getElementById('airlineSelect');
for(let iata in airlines){
    const opt = document.createElement('option');
    opt.value = iata;
    opt.textContent = airlines[iata];
    airlineSelect.appendChild(opt);
}

// ----- Initialize Zoom Airline Dropdown -----
const zoomAirlineSelect = document.getElementById('zoomAirlineSelect');
for(let iata in airlines){
    const opt = document.createElement('option');
    opt.value = iata;
    opt.textContent = airlines[iata];
    zoomAirlineSelect.appendChild(opt);
}

// ----- Seat input listener with auto-correction -----
seatInput.addEventListener('input', function() {
    const currentSeat = this.value.trim();
    const flightValue = flightInput.value.trim();
    
    if (currentSeat !== lastSeatValue) {
        // Auto-correct seat format (remove slashes)
        let correctedSeat = autoCorrectSeatFormat(currentSeat);
        
        // Additional correction for restricted airlines
        if (flightValue && isPaxRestrictedAirline(flightValue)) {
            correctedSeat = autoCorrectSeatForRestrictedAirline(flightValue, correctedSeat);
        }
        
        if (correctedSeat !== currentSeat) {
            this.value = correctedSeat;
        }
        
        checkSeatPaxMatch();
        lastSeatValue = this.value.trim();
        
        // Auto-correct pax based on seat (only for non-restricted airlines)
        if (this.value.trim()) {
            if (!isPaxRestrictedAirline(flightValue)) {
                autoCorrectPaxFromSeat(this, numPaxInput);
            } else {
                // For restricted airlines, always set pax to 1
                numPaxInput.value = '1';
            }
        }
    }
});

// ----- Zoom seat input listener with auto-correction -----
zoomSeatInput.addEventListener('input', function() {
    const flightValue = zoomFlightInput.value.trim();
    const seatValue = this.value.trim();
    
    // Auto-correct seat format (remove slashes)
    let correctedSeat = autoCorrectSeatFormat(seatValue);
    
    // Additional correction for restricted airlines
    if (flightValue && isPaxRestrictedAirline(flightValue)) {
        correctedSeat = autoCorrectSeatForRestrictedAirline(flightValue, correctedSeat);
    }
    
    if (correctedSeat !== seatValue) {
        this.value = correctedSeat;
    }
    
    checkZoomSeatPaxMatch();
    
    // Auto-correct pax based on seat
    if (this.value.trim()) {
        if (!isPaxRestrictedAirline(flightValue)) {
            autoCorrectPaxFromSeat(this, zoomPaxInput);
        } else {
            // For restricted airlines, always set pax to 1
            zoomPaxInput.value = '1';
        }
    }
});

// ----- Save Entry function with seat auto-correction -----
async function saveEntry(entry){
    if (!currentShiftType || currentShiftStatus !== 'open') {
        showAlert('No active shift or shift not open!', true);
        return;
    }
    
    entry.date = currentShiftDate;
    entry.shift = currentShiftType;
    
    // Auto-correct seat format (remove slashes) and handle restricted airlines
    if (entry.seat) {
        const correctedSeat = autoCorrectSeatForRestrictedAirline(entry.flight, entry.seat);
        if (correctedSeat !== entry.seat) {
            entry.seat = correctedSeat;
            seatInput.value = correctedSeat;
        }
    }
    
    // Validate seat-pax match
    const seatPaxValidation = validateSeatPaxMatch(entry.seat, entry.numPax);
    if (!seatPaxValidation.isValid) {
        showAlert(`Cannot save: ${seatPaxValidation.message}`, true);
        // Auto-correct pax
        entry.numPax = seatPaxValidation.calculatedPax;
        numPaxInput.value = seatPaxValidation.calculatedPax;
        showAlert(`Pax auto-corrected to ${seatPaxValidation.calculatedPax} based on seat ${entry.seat}`, false, false, true);
    }
    
    // Check for restricted airlines
    if (isPaxRestrictedAirline(entry.flight)) {
        if (entry.numPax !== 1) {
            showAlert(`Flight ${entry.flight} (${entry.flight.substring(0, 2)}) allows only 1 passenger per seat. Pax changed to 1.`, false, true);
            entry.numPax = 1;
            numPaxInput.value = '1';
        }
    }
    
    // Validate pax count
    const paxValidation = validatePaxCount(entry.flight, entry.seat, entry.numPax);
    if (!paxValidation.isValid) {
        showAlert(`Cannot save: ${paxValidation.message}`, true);
        return;
    }
    
    if (isDuplicateEntry(entry)) {
        console.log('Duplicate passenger detected, skipping save');
        showAlert(`${entry.name} is already entered for flight ${entry.flight}`, true);
        
        codeInput.value = '';
        codeInput.focus();
        setTimeout(clearInputFields, 2000);
        return;
    }
    
    const flightUpper = entry.flight.toUpperCase();
    const isQRFlight = flightUpper.startsWith('QR');
    
    let qrSaved = false;
    if (isQRFlight) {
        try {
            qrSaved = await saveToQRSystem(entry.code);
            if (qrSaved) {
                console.log('âœ… QR data saved successfully');
            }
        } catch (error) {
            console.error('âŒ Error saving QR data:', error);
        }
    }
    
    let data = JSON.parse(localStorage.getItem('codesData')||'[]');
    data.push(entry);
    localStorage.setItem('codesData', JSON.stringify(data));
    
    if (!renderTimeout) {
        renderTimeout = setTimeout(() => {
            renderEntries();
            renderTimeout = null;
        }, 50);
    }

    if (isQRFlight && qrSaved) {
        showAlert(`Entry saved! ${entry.name} - QR data saved to both systems`, false);
    } else if (isQRFlight && !qrSaved) {
        showAlert(`Entry saved! ${entry.name} - QR system save failed`, true);
    } else {
        showAlert(`Entry saved! ${entry.name}`);
    }

    codeInput.value = '';
    codeInput.focus();
    setTimeout(clearInputFields, 2000);
}

// ----- Save Zoom Entry with seat auto-correction -----
function saveZoomEntry() {
    const name = zoomNameInput.value.trim();
    const flight = zoomFlightInput.value.trim();
    let seat = zoomSeatInput.value.trim();
    const pax = parseInt(zoomPaxInput.value) || 1;
    
    if (!name) {
        showAlert('Please enter passenger name', true);
        zoomNameInput.focus();
        return;
    }
    
    if (!flight) {
        showAlert('Please enter flight number', true);
        zoomFlightInput.focus();
        return;
    }
    
    // Auto-correct seat format (remove slashes) and handle restricted airlines
    let correctedSeat = autoCorrectSeatForRestrictedAirline(flight, seat);
    if (correctedSeat !== seat) {
        zoomSeatInput.value = correctedSeat;
        seat = correctedSeat;
    }
    
    // Validate seat-pax match
    const seatPaxValidation = validateSeatPaxMatch(correctedSeat, pax);
    if (!seatPaxValidation.isValid) {
        showAlert(seatPaxValidation.message, true);
        zoomPaxInput.value = seatPaxValidation.calculatedPax;
        zoomPaxInput.focus();
        return;
    }
    
    // Validate restricted airlines
    if (isPaxRestrictedAirline(flight) && pax !== 1) {
        showAlert(`Flight ${flight} (${flight.substring(0, 2)}) allows only 1 passenger per seat`, true);
        zoomPaxInput.value = '1';
        zoomPaxInput.focus();
        return;
    }
    
    const entry = {
        date: currentShiftDate,
        user: userDisplay.textContent,
        shift: currentShiftType,
        code: 'MANUAL_ENTRY',
        name: name,
        pnr: zoomPnrInput.value.trim(),
        flight: flight,
        airline: zoomAirlineSelect.value,
        seat: correctedSeat,
        class: zoomClassInput.value.trim(),
        serial: zoomSerialInput.value.trim(),
        remarks: zoomRemarksInput.value.trim(),
        fqtv: zoomFqtvInput.value.trim(),
        numPax: pax,
        approved: false
    };
    
    saveEntry(entry);
    closeZoomModal();
}



// Modify the zoom cancel button to not clear manual fields
zoomCancelBtn.addEventListener('click', function() {
    closeZoomModal();
});

// ----- FQTV Zoom Modal Functions -----
function showFqtvZoomModal(rowIndex, cellElement = null) {
    currentEditingRowIndex = rowIndex;
    currentEditingField = 'fqtv';
    
    const data = JSON.parse(localStorage.getItem('codesData') || '[]');
    const entry = data[rowIndex];
    
    if (!entry) {
        showAlert('Entry not found', true);
        return;
    }
    
    // Set current FQTV value
    fqtvZoomInput.value = entry.fqtv || '';
    
    // Show modal
    fqtvZoomModal.classList.add('show');
    
    // Focus on input
    setTimeout(() => {
        fqtvZoomInput.focus();
        fqtvZoomInput.select();
        
        // Store the cell element for updating after save
        if (cellElement) {
            fqtvZoomInput.dataset.targetCell = 'stored';
        }
    }, 100);
}

function closeFqtvZoomModal() {
    fqtvZoomModal.classList.remove('show');
    currentEditingRowIndex = -1;
    currentEditingField = '';
}

// ----- Modified FQTV Zoom Save Button -----
fqtvZoomSaveBtn.addEventListener('click', function() {
    const newFqtv = fqtvZoomInput.value.trim();
    updateFqtvAndSave(newFqtv);
});

// ----- Auto-save on Enter key in FQTV zoom modal -----
fqtvZoomInput.addEventListener('keydown', function(event) {
    if (event.key === 'Enter') {
        event.preventDefault();
        const newFqtv = fqtvZoomInput.value.trim();
        updateFqtvAndSave(newFqtv);
    } else if (event.key === 'Tab') {
        event.preventDefault();
        const newFqtv = fqtvZoomInput.value.trim();
        updateFqtvAndSave(newFqtv);
    } else if (event.key === 'Escape') {
        event.preventDefault();
        closeFqtvZoomModal();
    }
});

// ----- Modified FQTV cell click handler -----
function handleFqtvCellClick(event) {
    const cell = event.target;
    const row = cell.closest('tr');
    const rowIndex = Array.from(row.parentNode.children).indexOf(row);
    
    if (rowIndex >= 0) {
        showFqtvZoomModal(rowIndex, cell);
    }
}

// ----- Add tab navigation support for FQTV field only -----
document.addEventListener('keydown', function(event) {
    // Check if we're in a table cell and Tab is pressed
    if (event.key === 'Tab' && event.target.classList.contains('editable-cell')) {
        const cell = event.target;
        const field = cell.getAttribute('data-field');
        
        // If it's the FQTV field, show zoom modal
        if (field === 'fqtv') {
            event.preventDefault(); // Prevent default tab behavior
            const row = cell.closest('tr');
            const rowIndex = Array.from(row.parentNode.children).indexOf(row);
            
            // Get current value
            const currentValue = cell.textContent.trim().replace('FQTV REQUIRED', '').trim();
            
            if (rowIndex >= 0) {
                showFqtvZoomModal(rowIndex, cell);
                // Set the current value in the modal
                setTimeout(() => {
                    fqtvZoomInput.value = currentValue;
                    fqtvZoomInput.select();
                }, 100);
            }
        }
    }
});

// ----- FIXED: Seat-Pax Validation (Only show alerts on actual changes) -----
function checkSeatPaxMatch() {
    const seat = seatInput.value.trim();
    const pax = parseInt(numPaxInput.value) || 1;
    
    // Only check if seat has value AND it's different from last value
    if (!seat || seat === lastSeatValue) {
        seatWarning.style.display = 'none';
        seatInput.parentElement.classList.remove('seat-pax-mismatch');
        numPaxInput.parentElement.style.borderColor = '';
        return;
    }
    
    // Update last value
    lastSeatValue = seat;
    
    const validation = validateSeatPaxMatch(seat, pax);
    if (!validation.isValid) {
        seatWarningText.textContent = validation.message;
        seatWarning.style.display = 'flex';
        
        // Add warning class to seat input
        seatInput.parentElement.classList.add('seat-pax-mismatch');
        
        // Highlight pax input too
        numPaxInput.parentElement.style.borderColor = 'var(--warning)';
    } else {
        seatWarning.style.display = 'none';
        seatInput.parentElement.classList.remove('seat-pax-mismatch');
        numPaxInput.parentElement.style.borderColor = '';
    }
}

function checkZoomSeatPaxMatch() {
    const seat = zoomSeatInput.value.trim();
    const pax = parseInt(zoomPaxInput.value) || 1;
    
    if (!seat) {
        zoomSeatWarning.style.display = 'none';
        return;
    }
    
    const validation = validateSeatPaxMatch(seat, pax);
    if (!validation.isValid) {
        zoomSeatWarningText.textContent = validation.message;
        zoomSeatWarning.style.display = 'flex';
        
        // Highlight inputs
        zoomSeatInput.style.borderColor = 'var(--warning)';
        zoomPaxInput.style.borderColor = 'var(--warning)';
    } else {
        zoomSeatWarning.style.display = 'none';
        zoomSeatInput.style.borderColor = '';
        zoomPaxInput.style.borderColor = '';
    }
}

// ----- Auto-correct Seat for Restricted Airlines -----
function autoCorrectSeatFromInput(inputElement, flightValue) {
    const seatValue = inputElement.value.trim();
    if (!seatValue || !flightValue) return;
    
    if (isPaxRestrictedAirline(flightValue)) {
        const correctedSeat = autoCorrectSeatForRestrictedAirline(flightValue, seatValue);
        if (correctedSeat !== seatValue) {
            inputElement.value = correctedSeat;
        }
    }
}

// ----- Auto-correct Pax based on Seat -----
function autoCorrectPaxFromSeat(inputElement, paxElement) {
    const seat = inputElement.value.trim();
    if (!seat) return;
    
    const calculatedPax = calculatePaxFromSeatNumber(seat);
    paxElement.value = calculatedPax;
    
    // Show notification if multiple seats detected
    if (calculatedPax > 1) {
        showAlert(`Pax auto-corrected to ${calculatedPax} based on seat ${seat}`, false, false, true);
    }
}

// ----- Generate Unique Key for QR Code -----
function generateUniqueKeyFromCode(codeValue) {
    let hash = 0;
    for (let i = 0; i < codeValue.length; i++) {
        const char = codeValue.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
    }
    return Math.abs(hash).toString(16);
}

// ----- Check QR Duplicate -----
function isQRDuplicate(uniqueKey) {
    if (qrEntriesProcessed.includes(uniqueKey)) {
        return true;
    }
    
    const processedCodes = JSON.parse(localStorage.getItem('qrProcessedCodes') || '[]');
    if (processedCodes.includes(uniqueKey)) {
        return true;
    }
    
    return false;
}

// ----- Mark QR as Processed -----
function markQRAsProcessed(uniqueKey) {
    qrEntriesProcessed.push(uniqueKey);
    
    const processedCodes = JSON.parse(localStorage.getItem('qrProcessedCodes') || '[]');
    if (!processedCodes.includes(uniqueKey)) {
        processedCodes.push(uniqueKey);
        if (processedCodes.length > 1000) {
            processedCodes.splice(0, processedCodes.length - 1000);
        }
        localStorage.setItem('qrProcessedCodes', JSON.stringify(processedCodes));
    }
}

// ----- Clear Old Processed Codes -----
function clearOldProcessedCodes() {
    const processedCodes = JSON.parse(localStorage.getItem('qrProcessedCodes') || '[]');
    const oneWeekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
    const recentCodes = processedCodes.filter(code => {
        const match = code.match(/_(\d+)$/);
        if (match) {
            const timestamp = parseInt(match[1]);
            return timestamp > oneWeekAgo;
        }
        return true;
    });
    
    localStorage.setItem('qrProcessedCodes', JSON.stringify(recentCodes));
    qrEntriesProcessed = recentCodes;
}

// ----- Initialize QR Firebase -----
function initializeQRFirebase() {
    try {
        console.log("ðŸ”„ Initializing QR Firebase...");
        
        if (!qrFirebaseConfig) {
            console.warn("âš ï¸ QR Firebase config not available");
            showAlert("QR system configuration not found", true);
            qrSystemAvailable = false;
            return false;
        }
        
        console.log("âœ… Using QR Firebase project:", qrFirebaseConfig.projectId);
        
        let qrApp;
        try {
            qrApp = firebase.app('qrSystem');
            console.log("âœ… Using existing QR Firebase app");
        } catch (e) {
            try {
                qrApp = firebase.initializeApp(qrFirebaseConfig, 'qrSystem');
                console.log("âœ… Created new QR Firebase app for project:", qrFirebaseConfig.projectId);
            } catch (initError) {
                console.error("âŒ Error creating QR Firebase app:", initError);
                showAlert("Failed to initialize QR system", true);
                qrSystemAvailable = false;
                return false;
            }
        }
        
        try {
            qrDb = firebase.firestore(qrApp);
            
            const settings = {
                cacheSizeBytes: firebase.firestore.CACHE_SIZE_UNLIMITED
            };
            
            qrDb.settings(settings);
            
            console.log("âœ… QR Firestore initialized");
            qrFirebaseInitialized = true;
            qrSystemAvailable = true;
            showAlert("QR system connected successfully", false, false, true);
            
            return true;
            
        } catch (firestoreError) {
            console.error("âŒ Error initializing QR Firestore:", firestoreError);
            
            qrDb = firebase.firestore(qrApp);
            qrFirebaseInitialized = true;
            qrSystemAvailable = true;
            
            if (firestoreError.code === 'permission-denied') {
                console.warn("âš ï¸ Permission denied - check Firebase rules for project:", qrFirebaseConfig.projectId);
                showAlert("QR system: Permission denied - check Firestore rules", true);
            } else {
                showAlert("QR system initialized (offline mode)", false, true, false);
            }
            
            return true;
        }
        
    } catch (error) {
        console.error("âŒ Unexpected error in QR Firebase initialization:", error);
        showAlert("QR system initialization error", true);
        qrSystemAvailable = false;
        return false;
    }
}

// ----- Load QR Entries -----
async function loadQREntries() {
    if (!qrFirebaseInitialized || !qrSystemAvailable) {
        console.log("QR system not available, skipping load");
        return;
    }
    
    try {
        console.log("ðŸ“¥ Loading QR entries from Firebase...");
        
        const snapshot = await qrDb.collection('flightEntries')
            .orderBy('timestamp', 'desc')
            .limit(100) // Reduced from 200 to save reads
            .get();
        
        qrEntries = [];
        snapshot.forEach(doc => {
            qrEntries.push({
                id: doc.id,
                ...doc.data()
            });
        });
        
        console.log(`âœ… Loaded ${qrEntries.length} QR entries from Firebase`);
        
    } catch (error) {
        console.error('âŒ Error loading QR entries:', error);
        qrStatus.innerHTML = `<span style="color: var(--error);"><i class="fas fa-exclamation-circle"></i> QR load failed: ${error.message}</span>`;
    }
}

// ----- Save to QR System -----
async function saveToQRSystem(codeValue) {
    if (!qrFirebaseInitialized || !qrSystemAvailable) {
        console.log("QR system not available, skipping save");
        return false;
    }
    
    try {
        qrProcessingIndicator.classList.add('show');
        
        const uniqueKey = generateUniqueKeyFromCode(codeValue);
        
        if (isQRDuplicate(uniqueKey)) {
            console.log("âš ï¸ Duplicate QR code detected, skipping save");
            qrProcessingIndicator.classList.remove('show');
            qrStatus.innerHTML = `<span style="color: var(--warning);"><i class="fas fa-exclamation-triangle"></i> Duplicate QR code - already processed</span>`;
            return false;
        }
        
        const qrData = extractQRDataFromCode(codeValue);
        
        // FIXED: Use the new tier mapping function for QR system
        if (qrData.originalTier) {
            const tierUpper = qrData.originalTier.toUpperCase();
            // Use processFqtvTierWithAirline for QR system too
            const formattedTier = processFqtvTierWithAirline(`${qrData.ffpOwner || ''} ${qrData.ffpNumber || ''}/${tierUpper}`, qrData.carrierCode);
            qrData.ffpTier = formattedTier;
        }
        
        markQRAsProcessed(uniqueKey);
        
        qrData.processedAt = getMaldivesDateTimeISO();
        qrData.processedBy = userDisplay.textContent;
        qrData.sourceSystem = 'UnifiedCardEntry';
        qrData.uniqueKey = uniqueKey;
        
        if (!qrData.timestamp) {
            qrData.timestamp = firebase.firestore.FieldValue.serverTimestamp();
        }
        
        console.log("ðŸ’¾ Attempting to save QR data to project:", qrFirebaseConfig.projectId, {
            flight: qrData.flightNumber,
            passenger: `${qrData.firstName} ${qrData.lastName}`,
            carrier: qrData.carrierCode,
            seat: qrData.seatNumber,
            secNumber: qrData.secNumber,
            ffpTier: qrData.ffpTier // Debug log
        });
        
        const docRef = await qrDb.collection('flightEntries').add(qrData);
        qrData.id = docRef.id;
        
        qrEntries.unshift(qrData);
        qrEntriesLocal.push({
            ...qrData,
            synced: true,
            syncedAt: getMaldivesDateTimeISO()
        });
        
        console.log('âœ… QR entry saved to Firebase with ID:', docRef.id);
        qrProcessingIndicator.classList.remove('show');
        
        qrStatus.innerHTML = `<span style="color: var(--qr-green);"><i class="fas fa-check-circle"></i> QR entry saved successfully!</span>`;
        
        setTimeout(() => {
            qrStatus.innerHTML = '';
        }, 3000);
        
        return true;
        
    } catch (error) {
        console.error('âŒ Error saving to QR system:', error);
        qrProcessingIndicator.classList.remove('show');
        
        let errorMessage = error.message;
        if (error.code === 'permission-denied') {
            errorMessage = 'Permission denied - check Firebase Firestore rules';
            console.error('ðŸ”’ Firestore Rules Issue: Go to Firebase Console â†’ Firestore Database â†’ Rules');
            console.error('ðŸ”’ Project:', qrFirebaseConfig.projectId);
        } else if (error.message.includes('timeout')) {
            errorMessage = 'Save timeout - check connection';
        } else if (error.message.includes('network')) {
            errorMessage = 'Network error - working offline';
        }
        
        qrStatus.innerHTML = `<span style="color: var(--error);"><i class="fas fa-exclamation-circle"></i> QR save failed: ${errorMessage}</span>`;
        
        storeQRDataLocally(codeValue);
        
        return false;
    }
}

// ----- Store QR Data Locally -----
function storeQRDataLocally(codeValue) {
    try {
        const qrData = extractQRDataFromCode(codeValue);
        
        // FIXED: Use the new tier mapping function for local storage too
        if (qrData.originalTier) {
            const tierUpper = qrData.originalTier.toUpperCase();
            const formattedTier = processFqtvTierWithAirline(`${qrData.ffpOwner || ''} ${qrData.ffpNumber || ''}/${tierUpper}`, qrData.carrierCode);
            qrData.ffpTier = formattedTier;
        }
        
        qrData.localSaveTime = getMaldivesDateTimeISO();
        qrData.status = 'pending_sync';
        
        let localQRData = JSON.parse(localStorage.getItem('localQRData') || '[]');
        
        const isDuplicate = localQRData.some(item => 
            item.uniqueKey === qrData.uniqueKey
        );
        
        if (!isDuplicate) {
            localQRData.push(qrData);
            localStorage.setItem('localQRData', JSON.stringify(localQRData));
            console.log('ðŸ’¾ QR data stored locally for later sync');
        }
        
    } catch (error) {
        console.error('Error storing QR data locally:', error);
    }
}

// ----- Extract QR Data from Code -----
function extractQRDataFromCode(codeValue) {
    let data = {
        firstName: '',
        lastName: '',
        carrierCode: '',
        destination: '',
        origin: '',
        flightNumber: '',
        seatNumber: '',
        cabinCode: '',
        secNumber: '',
        ffpOwner: '',
        ffpNumber: '',
        ffpTier: '',
        originalTier: '',
        guestCategory: 'Guest',
        paxType: 'Adult',
        cabin: 'Economy',
        flightDate: getCurrentDate(),
        originalCode: codeValue,
        uniqueKey: generateUniqueKeyFromCode(codeValue)
    };
    
    codeValue = codeValue.toUpperCase().replace(/\s+/g, ' ').trim();
    
    const mlePos = codeValue.indexOf('MLE');
    
    if (mlePos !== -1) {
        const textBeforeMLE = codeValue.substring(0, mlePos);
        let processedText = '';
        
        if (textBeforeMLE.length >= 8) {
            processedText = textBeforeMLE.substring(2, textBeforeMLE.length - 7);
        } else if (textBeforeMLE.length > 2) {
            processedText = textBeforeMLE.substring(2);
        }
        
        if (processedText.includes('/')) {
            const nameParts = processedText.split('/');
            if (nameParts.length >= 2) {
                data.lastName = nameParts[0].trim();
                data.firstName = nameParts[1].trim();
            } else if (nameParts.length === 1) {
                data.lastName = nameParts[0].trim();
            }
        } else {
            data.lastName = processedText.trim();
        }
        
        let wordStart = mlePos;
        let wordEnd = mlePos + 3;
        
        while (wordStart > 0 && /[A-Z0-9]/.test(codeValue[wordStart - 1])) {
            wordStart--;
        }
        
        while (wordEnd < codeValue.length && /[A-Z0-9]/.test(codeValue[wordEnd])) {
            wordEnd++;
        }
        
        const mleWord = codeValue.substring(wordStart, wordEnd);
        
        data.carrierCode = mleWord.length >= 2 ? mleWord.substring(mleWord.length - 2) : mleWord;
        
        if (mleWord.length >= 5) {
            data.destination = mleWord.substring(3, mleWord.length - 2);
        }
        
        if (mleWord.length >= 3) {
            data.origin = mleWord.substring(0, 3);
        }
        
        let nextWordStart = wordEnd;
        
        while (nextWordStart < codeValue.length && !/[A-Z0-9]/.test(codeValue[nextWordStart])) {
            nextWordStart++;
        }
        
        let nextWordEnd = nextWordStart;
        while (nextWordEnd < codeValue.length && /[A-Z0-9]/.test(codeValue[nextWordEnd])) {
            nextWordEnd++;
        }
        
        if (nextWordStart < codeValue.length) {
            data.flightNumber = codeValue.substring(nextWordStart, nextWordEnd);
        }
        
        let seatWordStart = nextWordEnd;
        
        while (seatWordStart < codeValue.length && !/[A-Z0-9]/.test(codeValue[seatWordStart])) {
            seatWordStart++;
        }
        
        let seatWordEnd = seatWordStart;
        while (seatWordEnd < codeValue.length && /[A-Z0-9]/.test(codeValue[seatWordEnd])) {
            seatWordEnd++;
        }
        
        if (seatWordStart < codeValue.length) {
            const seatWord = codeValue.substring(seatWordStart, seatWordEnd);
            
            console.log("Seat word:", seatWord);
            
            if (seatWord.length >= 9) {
                const rowPart = seatWord.substring(5, seatWord.length - 5);
                const seatLetter = seatWord.substring(seatWord.length - 5, seatWord.length - 4);
                data.seatNumber = rowPart + seatLetter;
                console.log("Seat number extracted:", data.seatNumber);
            }
            
            if (seatWord.length >= 4) {
                data.cabinCode = seatWord.substring(3, 4);
            }
            
            if (seatWord.length >= 4) {
                const last4Chars = seatWord.substring(seatWord.length - 4);
                if (/^\d{4}$/.test(last4Chars)) {
                    data.secNumber = last4Chars.substring(1);
                } else {
                    let digitsEnd = seatWord.length;
                    let digitsStart = seatWord.length - 1;
                    
                    while (digitsStart >= 0 && /\d/.test(seatWord[digitsStart])) {
                        digitsStart--;
                    }
                    
                    digitsStart++;
                    
                    if (digitsStart < digitsEnd) {
                        const secDigits = seatWord.substring(digitsStart, digitsEnd);
                        if (secDigits.length >= 4) {
                            data.secNumber = secDigits.substring(1);
                        } else {
                            data.secNumber = secDigits;
                        }
                    }
                }
                console.log("SEC number extracted:", data.secNumber);
            }
        }
        
        const words = codeValue.split(' ').filter(word => word.trim() !== '');
        let ffpOwner = '';
        let ffpNumber = '';
        let ffpTier = '';
        let originalTier = '';
        
        if (words.length >= 2) {
            const lastWord = words[words.length - 1];
            const secondLastWord = words[words.length - 2];
            
            if (secondLastWord.length < 4) {
                ffpOwner = '';
                ffpNumber = '';
                ffpTier = '';
                originalTier = '';
            } else {
                ffpNumber = secondLastWord;
                
                if (words.length >= 3) {
                    const thirdLastWord = words[words.length - 3];
                    if (thirdLastWord.length === 2 && /^[A-Z]{2}$/.test(thirdLastWord)) {
                        ffpOwner = thirdLastWord;
                    }
                }
                
                if (lastWord.length === 2 && /^[A-Z0-9]{2}$/.test(lastWord.toUpperCase())) {
                    originalTier = lastWord.toUpperCase();
                    // Map tier code to letter (P/G/S)
                    if (originalTier === 'N1') {
                        ffpTier = 'P';
                    } else if (originalTier === 'N2') {
                        ffpTier = 'G';
                    } else if (originalTier === 'N3') {
                        ffpTier = 'S';
                    } else if (originalTier === 'N0') {
                        ffpTier = 'N0';
                    } else {
                        ffpTier = originalTier;
                    }
                }
            }
        }
        
        data.ffpOwner = ffpOwner;
        data.ffpNumber = ffpNumber;
        data.ffpTier = ffpTier;
        data.originalTier = originalTier;
        
        switch(data.cabinCode) {
            case 'J':
                data.cabin = 'Business';
                break;
            case 'Y':
                data.cabin = 'Economy';
                break;
            case 'F':
                data.cabin = 'First';
                break;
            default:
                data.cabin = 'Economy';
        }
        
        const cabinCodeUpper = (data.cabinCode || '').toUpperCase();
        const cabinNameLower = (data.cabin || '').toLowerCase();
        const isEconomy = (cabinCodeUpper === 'Y' || cabinNameLower.includes('economy'));
        
        const ffpTierUpper = (data.ffpTier || '').toUpperCase();
        const isN0Tier = ffpTierUpper === 'N0' || ffpTierUpper.includes('N0');
        const isTierEmpty = !data.ffpTier || data.ffpTier.trim() === '';
        const isFFPNumberEmpty = !data.ffpNumber || data.ffpNumber.trim() === '';
        
        if (isEconomy && (isN0Tier || isTierEmpty || isFFPNumberEmpty)) {
            data.guestCategory = 'Guest';
        } else if (isEconomy && data.ffpNumber && data.ffpNumber.trim() !== '') {
            data.guestCategory = 'Primary';
        } else {
            data.guestCategory = 'Primary';
        }
        
        const carrierUpper = (data.carrierCode || '').toUpperCase();
        const tierUpper = (data.ffpTier || '').toUpperCase();
        const originalTierUpper = (data.originalTier || '').toUpperCase();
        
        if (carrierUpper === 'QR') {
            const isExactlyN0 = tierUpper === 'N0' || originalTierUpper === 'N0';
            const isEmptyTier = (tierUpper === '' || tierUpper === null || tierUpper === undefined) && 
                              (originalTierUpper === '' || originalTierUpper === null || originalTierUpper === undefined);
            
            if (isExactlyN0 || isEmptyTier) {
                data.ffpOwner = '';
                data.ffpNumber = '';
                data.ffpTier = '';
            }
        }
    }
    
    return data;
}

// ----- User Authentication -----
const userData = JSON.parse(localStorage.getItem("loggedInUser"));

if (userData) {
    userDisplay.textContent = userData.name || userData.username;
} else {
    window.location.href = "login.html";
}

// ----- Initialize Shift Firebase -----
function initializeShiftFirebase() {
    try {
        console.log("Initializing Shift Firebase...");
        
        if (typeof shiftFirebaseConfig === 'undefined') {
            console.error("âŒ Shift Firebase config not found in fireshift.js");
            showAlert("Shift system configuration not found", true);
            return false;
        }
        
        console.log("Using Firebase config for project:", shiftFirebaseConfig.projectId);
        
        let app;
        try {
            app = firebase.app('shiftSystem');
            console.log("âœ… Using existing Shift Firebase app");
        } catch (e) {
            app = firebase.initializeApp(shiftFirebaseConfig, 'shiftSystem');
            console.log("âœ… Created new Shift Firebase app");
        }
        
        shiftDb = firebase.firestore(app);
        shiftCacheInitialized = true;
        console.log("âœ… Shift Firestore initialized successfully");
        
        return true;
        
    } catch (error) {
        console.error("âŒ Error initializing shift Firebase:", error);
        showAlert("Failed to initialize shift system", true);
        return false;
    }
}

// ----- Check for Open Shift -----
function checkForOpenShift(shiftData) {
    console.log("ðŸ” Checking for open shift in data...");
    
    let result = {
        success: false,
        isActive: false,
        shiftName: "No Shift Open",
        shiftType: "",
        openTime: "",
        details: {}
    };
    
    if (!shiftData) {
        return result;
    }
    
    if (shiftData.morning && shiftData.morning.status === 'open') {
        result.success = true;
        result.isActive = true;
        result.shiftName = "Morning Shift";
        result.shiftType = "morning";
        result.openTime = shiftData.morning.open || "";
        result.details = shiftData.morning;
        console.log("âœ“ Morning shift is OPEN");
        return result;
    }
    
    if (shiftData.evening && shiftData.evening.status === 'open') {
        result.success = true;
        result.isActive = true;
        result.shiftName = "Evening Shift";
        result.shiftType = "evening";
        result.openTime = shiftData.evening.open || "";
        result.details = shiftData.evening;
        console.log("âœ“ Evening shift is OPEN");
        return result;
    }
    
    if (shiftData.morning || shiftData.evening) {
        result.success = true;
        result.shiftName = "Shift Not Open";
        console.log("âš ï¸ Shift exists but not open");
    }
    
    return result;
}

// ----- Fetch Current Open Shift -----
async function fetchCurrentOpenShift() {
    console.log("ðŸŒ Fetching current open shift...");
    
    try {
        refreshShiftBtn.disabled = true;
        refreshShiftBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
        
        if (!shiftCacheInitialized) {
            if (!initializeShiftFirebase()) {
                showNoShiftMessage();
                refreshShiftBtn.disabled = false;
                refreshShiftBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
                return;
            }
        }
        
        const now = Date.now();
        if (shiftCache.data && (now - shiftCache.timestamp < shiftCache.ttl)) {
            console.log("ðŸ“Š Using cached shift data");
            const shiftCheck = checkForOpenShift(shiftCache.data);
            if (shiftCheck.isActive) {
                updateShiftUI(shiftCheck, shiftCache.dateKey, shiftCache.dateKey !== getCurrentDate());
                refreshShiftBtn.disabled = false;
                refreshShiftBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
                return;
            }
        }
        
        const maldivesNow = getMaldivesTime();
        const todayDateForYYYYMMDD = formatDateToYYYYMMDD(maldivesNow);
        const todayDateForDocId = formatDateForDocumentId(maldivesNow);
        const todayDocId = `shift_${todayDateForDocId}`;
        
        console.log("ðŸ“… Today's date:", todayDateForYYYYMMDD);
        console.log("ðŸ“„ Document ID:", todayDocId);
        
        let shiftData = null;
        let foundDate = todayDateForYYYYMMDD;
        let shiftCheck = null;
        let isFromPreviousDay = false;
        
        try {
            const todayShiftDoc = await shiftDb.collection("shifts").doc(todayDocId).get();
            
            if (todayShiftDoc.exists) {
                shiftData = todayShiftDoc.data();
                console.log("âœ… Found today's shift document");
                console.log("Shift data:", shiftData);
                
                shiftCheck = checkForOpenShift(shiftData);
                
                if (shiftCheck.isActive) {
                    console.log("ðŸŽ‰ Active shift found for today");
                } else {
                    console.log("âš ï¸ No active shift today, checking previous day...");
                    const previousResult = await checkPreviousDayForOpenShift();
                    if (previousResult.success && previousResult.shiftCheck.isActive) {
                        shiftData = previousResult.shiftData;
                        foundDate = previousResult.foundDate;
                        shiftCheck = previousResult.shiftCheck;
                        isFromPreviousDay = true;
                        console.log(`âœ… Found open shift from ${foundDate} (previous day)`);
                    }
                }
            } else {
                console.log("âš ï¸ No shift document for today, checking previous day...");
                const previousResult = await checkPreviousDayForOpenShift();
                if (previousResult.success && previousResult.shiftCheck.isActive) {
                    shiftData = previousResult.shiftData;
                    foundDate = previousResult.foundDate;
                    shiftCheck = previousResult.shiftCheck;
                    isFromPreviousDay = true;
                    console.log(`âœ… Found open shift from ${foundDate} (previous day)`);
                }
            }
        } catch (error) {
            console.error("âŒ Error fetching shift document:", error);
            showAlert("Error fetching shift data", true);
            refreshShiftBtn.disabled = false;
            refreshShiftBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
            return;
        }
        
        if (!shiftCheck || !shiftCheck.isActive) {
            console.log("âŒ No active shift found anywhere");
            showNoShiftMessage();
            showAlert("No active shift found. Please open a shift in Shift Management.", true);
            refreshShiftBtn.disabled = false;
            refreshShiftBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
            return;
        }
        
        shiftCache.data = shiftData;
        shiftCache.timestamp = now;
        shiftCache.dateKey = foundDate;
        shiftCache.shiftType = shiftCheck.shiftType;
        shiftCache.openTime = shiftCheck.openTime;
        
        updateShiftUI(shiftCheck, foundDate, isFromPreviousDay);
        
        console.log("âœ… Shift loaded successfully");
        
    } catch (error) {
        console.error("âŒ Error fetching shift data:", error);
        showNoShiftMessage();
        showAlert("Error loading shift information: " + error.message, true);
    } finally {
        refreshShiftBtn.disabled = false;
        refreshShiftBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
    }
}

// ----- Check Previous Day for Open Shift -----
async function checkPreviousDayForOpenShift() {
    try {
        const todayMaldives = getMaldivesTime();
        const yesterday = new Date(todayMaldives);
        yesterday.setDate(todayMaldives.getDate() - 1);
        
        const yesterdayForDocId = formatDateForDocumentId(yesterday);
        const yesterdayDocId = `shift_${yesterdayForDocId}`;
        const yesterdayDate = formatDateToYYYYMMDD(yesterday);
        
        console.log(`ðŸ” Checking previous day: ${yesterdayDocId} (${yesterdayDate})`);
        
        const yesterdayDoc = await shiftDb.collection("shifts").doc(yesterdayDocId).get();
        
        if (yesterdayDoc.exists) {
            const shiftData = yesterdayDoc.data();
            console.log(`âœ… Found shift document for previous day`);
            
            const shiftCheck = checkForOpenShift(shiftData);
            
            if (shiftCheck.isActive) {
                return {
                    success: true,
                    shiftData: shiftData,
                    foundDate: yesterdayDate,
                    foundDateForDocId: yesterdayForDocId,
                    shiftCheck: shiftCheck,
                    isFromPreviousDay: true
                };
            } else {
                console.log("âš ï¸ Previous day shift exists but not open");
            }
        } else {
            console.log("âš ï¸ No shift document for previous day");
        }
        
        return {
            success: false,
            message: "No open shift found in previous day"
        };
        
    } catch (error) {
        console.error("âŒ Error checking previous day:", error);
        return {
            success: false,
            message: "Error: " + error.message
        };
    }
}

// ----- Update Shift UI -----
function updateShiftUI(shiftCheck, foundDate, isFromPreviousDay = false) {
    currentShiftType = shiftCheck.shiftType;
    currentShiftDate = foundDate;
    currentShiftStatus = 'open';
    
    const displayDate = formatDateForDisplay(foundDate);
    
    let dateIndicator = "";
    if (isFromPreviousDay) {
        const foundDateObj = new Date(foundDate);
        const todayDateStr = getCurrentDate();
        const todayDateObj = new Date(todayDateStr);
        const daysDiff = Math.floor((todayDateObj - foundDateObj) / (1000 * 60 * 60 * 24));
        
        if (daysDiff === 1) {
            dateIndicator = " (Yesterday)";
        } else if (daysDiff > 1) {
            dateIndicator = ` (${daysDiff} days ago)`;
        }
    }
    
    shiftDisplay.textContent = shiftCheck.shiftName;
    dateDisplay.textContent = displayDate + dateIndicator;
    
    passengerEntryCard.classList.remove("disabled");
    
    saveCurrentShiftToLocalStorage(shiftCheck.shiftName, 'open', foundDate, isFromPreviousDay);
    
    updateExistingEntriesDate();
    
    showAlert(`${shiftCheck.shiftName} is OPEN - Date: ${displayDate}`, false);
    
    console.log("âœ… Shift UI updated:", {
        shift: shiftCheck.shiftName,
        date: foundDate,
        isFromPreviousDay: isFromPreviousDay
    });
}

// ----- Save Shift to LocalStorage -----
function saveCurrentShiftToLocalStorage(shiftName, shiftStatus, foundDate, isFromPreviousDay = false) {
    const shiftInfo = {
        shiftName: shiftName,
        shiftType: currentShiftType,
        shiftDate: foundDate,
        shiftStatus: shiftStatus,
        isFromPreviousDay: isFromPreviousDay,
        lastUpdated: getMaldivesDateTimeISO(),
        fetchedAt: getCurrentTime()
    };
    
    localStorage.setItem('currentShiftInfo', JSON.stringify(shiftInfo));
    console.log("ðŸ’¾ Shift saved to localStorage:", shiftInfo);
}

// ----- Load Shift from LocalStorage -----
function loadCurrentShiftFromLocalStorage() {
    try {
        const savedShift = localStorage.getItem('currentShiftInfo');
        if (savedShift) {
            const shiftInfo = JSON.parse(savedShift);
            
            const lastUpdated = new Date(shiftInfo.lastUpdated);
            const now = getMaldivesTime();
            const minutesDiff = (now - lastUpdated) / (1000 * 60);
            
            if (minutesDiff < 30 && shiftInfo.shiftStatus === 'open') { // Increased from 10 to 30 minutes
                console.log("ðŸ“‚ Loading shift from localStorage (fresh cache)");
                
                currentShiftType = shiftInfo.shiftType;
                currentShiftDate = shiftInfo.shiftDate;
                currentShiftStatus = shiftInfo.shiftStatus;
                
                let displayDate = formatDateForDisplay(shiftInfo.shiftDate);
                if (shiftInfo.isFromPreviousDay) {
                    const shiftDateObj = new Date(shiftInfo.shiftDate);
                    const todayDateStr = getCurrentDate();
                    const todayDateObj = new Date(todayDateStr);
                    const daysDiff = Math.floor((todayDateObj - shiftDateObj) / (1000 * 60 * 60 * 24));
                    
                    if (daysDiff === 1) {
                        displayDate += " (Yesterday)";
                    } else if (daysDiff > 1) {
                        displayDate += ` (${daysDiff} days ago)`;
                    }
                }
                
                shiftDisplay.textContent = shiftInfo.shiftName;
                dateDisplay.textContent = displayDate;
                passengerEntryCard.classList.remove("disabled");
                
                console.log("âœ… Shift loaded from cache:", shiftInfo.shiftName);
                return true;
            } else {
                console.log("ðŸ”„ LocalStorage cache expired, fetching fresh data");
                localStorage.removeItem('currentShiftInfo');
            }
        }
    } catch (error) {
        console.error("âŒ Error loading shift from localStorage:", error);
        localStorage.removeItem('currentShiftInfo');
    }
    return false;
}

// ----- Show No Shift Message -----
function showNoShiftMessage() {
    shiftDisplay.textContent = "No Shift";
    dateDisplay.textContent = "-";
    passengerEntryCard.classList.add("disabled");
    currentShiftType = null;
    currentShiftDate = null;
    currentShiftStatus = 'not_started';
    
    console.log("âš ï¸ No active shift - system disabled");
}

// ----- Update Existing Entries Date -----
function updateExistingEntriesDate() {
    if (!currentShiftType || !currentShiftDate) return;
    
    let data = JSON.parse(localStorage.getItem('codesData') || '[]');
    
    let updated = false;
    data = data.map(entry => {
        if (!entry.approved && entry.date !== currentShiftDate) {
            entry.date = currentShiftDate;
            entry.shift = currentShiftType;
            updated = true;
        }
        return entry;
    });
    
    if (updated) {
        localStorage.setItem('codesData', JSON.stringify(data));
        renderEntries();
        console.log("ðŸ“ Updated existing entries to current shift date");
    }
}

// ----- Refresh Shift Data -----
async function refreshShiftData() {
    console.log("ðŸ”„ Manual shift refresh requested");
    
    try {
        refreshShiftBtn.disabled = true;
        refreshShiftBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Refreshing...';
        
        shiftCache.data = null;
        shiftCache.timestamp = 0;
        localStorage.removeItem('currentShiftInfo');
        
        await fetchCurrentOpenShift();
        
        console.log("âœ… Shift data refreshed");
        
    } catch (error) {
        console.error("âŒ Error refreshing shift:", error);
        showAlert("Error refreshing shift data", true);
    } finally {
        refreshShiftBtn.disabled = false;
        refreshShiftBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
    }
}

// ----- FIXED: Approve Entry with new FQTV tier mapping -----
async function approveEntry(index) {
    if (!currentShiftType || currentShiftStatus !== 'open') {
        showAlert('No active shift or shift not open!', true);
        return;
    }
    
    if (isApproving) {
        return;
    }
    
    isApproving = true;
    
    try {
        let data = JSON.parse(localStorage.getItem('codesData')||'[]');
        const entry = data[index];
        
        if (!entry) {
            isApproving = false;
            return;
        }

        // Auto-correct seat for restricted airlines
        let correctedSeat = entry.seat;
        if (isPaxRestrictedAirline(entry.flight)) {
            correctedSeat = autoCorrectSeatForRestrictedAirline(entry.flight, correctedSeat);
            if (correctedSeat !== entry.seat) {
                entry.seat = correctedSeat;
                localStorage.setItem('codesData', JSON.stringify(data));
            }
        }

        // Validate seat-pax match after correction
        const seatPaxValidation = validateSeatPaxMatch(correctedSeat, entry.numPax);
        if (!seatPaxValidation.isValid) {
            showAlert(`Cannot approve: ${seatPaxValidation.message}`, true);
            isApproving = false;
            return;
        }

        // Validate pax count before approval
        const paxValidation = validatePaxCount(entry.flight, correctedSeat, entry.numPax);
        if (!paxValidation.isValid) {
            showAlert(`Cannot approve: ${paxValidation.message}`, true);
            isApproving = false;
            return;
        }

        if (isFqtvRequired(entry.class, entry.fqtv)) {
            showAlert(`Cannot approve: Economy Class passenger requires FQTV card or primary guest seat`, true);
            isApproving = false;
            return;
        }

        const flightUpper = entry.flight.toUpperCase();
        const nameUpper = entry.name.toUpperCase();
        const seatUpper = correctedSeat.toUpperCase();
        
        const duplicateCheck = checkDuplicateInCache(entry.flight, correctedSeat, currentShiftDate, entry.name);
        if (duplicateCheck.isDuplicate) {
            showAlert(duplicateCheck.message, true);
            isApproving = false;
            
            data.splice(index, 1);
            localStorage.setItem('codesData', JSON.stringify(data));
            renderEntries();
            return;
        }
        
        // FIXED: Use the new formatFqtvWithTier function
        let processedFqtv = '';
        if (entry.fqtv && entry.fqtv.trim() !== '') {
            processedFqtv = formatFqtvWithTier(entry.fqtv, entry.flight);
        }

        const approvedEntry = {
            airline: airlines[entry.airline] || entry.airline,
            approved: true,
            checkinTime: "",
            date: currentShiftDate,
            flightNo: flightUpper,
            fqtv: processedFqtv,
            name: entry.name,
            numPax: Number(entry.numPax) || 0,
            remarks: entry.remarks || "-",
            seatNo: seatUpper,
            class: entry.class || "-",
            pnr: entry.pnr,
            serial: entry.serial || "-",
            shift: currentShiftType,
            timeAdded: getCurrentTime(),
            approvedBy: userData ? userData.name : 'Unknown',
            approvedAt: getMaldivesDateTimeISO(),
            localId: `local_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            synced: false,
            syncedAt: null,
            originalEntry: entry
        };

        let docName;
        const timestamp = Date.now();
        const randomSuffix = Math.random().toString(36).substring(2, 8);
        
        if (flightUpper.startsWith('SQ')) {
            const cleanName = nameUpper.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 30);
            docName = `${approvedEntry.date}_${flightUpper}_${cleanName}_${timestamp}_${randomSuffix}`;
        } else {
            docName = `${approvedEntry.date}_${flightUpper}_${seatUpper}_${timestamp}`;
        }
        
        approvedEntry.docName = docName;
        
        // Save to localStorage first
        saveToApprovedCache(entry.flight, correctedSeat, approvedEntry.date, entry.name, docName);
        
        let approvedLocalData = JSON.parse(localStorage.getItem('approvedLocalData') || '[]');
        approvedLocalData.push(approvedEntry);
        localStorage.setItem('approvedLocalData', JSON.stringify(approvedLocalData));
        
        data.splice(index, 1);
        localStorage.setItem('codesData', JSON.stringify(data));
        
        renderEntries();
        
        showAlert(`Entry approved and saved to local storage!`, false);
        
        // Then save to Firebase in background
        if (window.passengerDb) {
            addToBackgroundSaveQueue(approvedEntry);
        } else {
            showAlert("Approved locally, will sync to server when connection available", true);
        }
        
    } catch (e) {
        console.error('Error in approval:', e);
        showAlert('Error: ' + e.message, true);
    } finally {
        isApproving = false;
    }
}

// ----- Background Save Queue Management -----
function addToBackgroundSaveQueue(approvedEntry) {
    backgroundSaveQueue.push(approvedEntry);
    
    if (!isBackgroundSaving) {
        processBackgroundSaveQueue();
    }
}

async function processBackgroundSaveQueue() {
    if (isBackgroundSaving || backgroundSaveQueue.length === 0) return;
    
    isBackgroundSaving = true;
    
    while (backgroundSaveQueue.length > 0) {
        const approvedEntry = backgroundSaveQueue[0];
        
        try {
            // Remove the synced field before saving to Firebase
            const firebaseEntry = { ...approvedEntry };
            delete firebaseEntry.synced;
            delete firebaseEntry.syncedAt;
            delete firebaseEntry.localId;
            delete firebaseEntry.originalEntry;
            
            await window.passengerDb.collection('passengers').doc(approvedEntry.docName).set(firebaseEntry);
            console.log(`âœ… Firebase save completed: ${approvedEntry.docName}`);
            
            // Mark as synced in localStorage
            markAsSyncedInLocalStorage(approvedEntry.localId);
            backgroundSaveQueue.shift();
            
            await new Promise(resolve => setTimeout(resolve, 100));
        } catch (error) {
            console.error('âŒ Firebase save failed:', error);
            const failedEntry = backgroundSaveQueue.shift();
            backgroundSaveQueue.push(failedEntry);
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }
    
    isBackgroundSaving = false;
}

function markAsSyncedInLocalStorage(localId) {
    try {
        let approvedLocalData = JSON.parse(localStorage.getItem('approvedLocalData') || '[]');
        
        approvedLocalData = approvedLocalData.map(item => {
            if (item.localId === localId) {
                return {
                    ...item,
                    synced: true,
                    syncedAt: getMaldivesDateTimeISO()
                };
            }
            return item;
        });
        
        localStorage.setItem('approvedLocalData', JSON.stringify(approvedLocalData));
        console.log(`âœ… Marked entry ${localId} as synced in localStorage`);
    } catch (error) {
        console.error('Error marking as synced:', error);
    }
}

// ----- Load Approved Entries Cache -----
function loadApprovedEntriesCache() {
    try {
        const cacheData = localStorage.getItem('approvedEntriesCache');
        if (cacheData) {
            approvedEntriesCache = JSON.parse(cacheData);
            console.log(`âœ… Loaded ${Object.keys(approvedEntriesCache).length} approved entries from cache`);
        }
    } catch (error) {
        console.error('âŒ Error loading approved entries cache:', error);
        approvedEntriesCache = {};
    }
}

// ----- Save Approved Entry to Cache -----
function saveToApprovedCache(flight, seat, date, name = null, docId = null) {
    const flightUpper = flight.toUpperCase();
    const nameUpper = name ? name.toUpperCase() : '';
    const seatUpper = seat ? seat.toUpperCase() : '';
    const timestamp = Date.now();
    
    if (flightUpper.startsWith('SQ')) {
        if (nameUpper) {
            const uniqueKey = `${date}_SQ_${nameUpper}_${timestamp}`;
            approvedEntriesCache[uniqueKey] = {
                date: date,
                flight: flightUpper,
                name: nameUpper,
                seat: seatUpper || '',
                cachedAt: getMaldivesDateTimeISO(),
                docId: docId,
                timestamp: timestamp
            };
        }
    } else {
        const seatKey = `${date}_${flightUpper}_${seatUpper}`;
        approvedEntriesCache[seatKey] = {
            date: date,
            flight: flightUpper,
            seat: seatUpper,
            cachedAt: getMaldivesDateTimeISO(),
            docId: docId
        };
    }
    
    localStorage.setItem('approvedEntriesCache', JSON.stringify(approvedEntriesCache));
}

// ----- Check Duplicate in Cache -----
function checkDuplicateInCache(flight, seat, date, name = null) {
    const flightUpper = flight.toUpperCase();
    const nameUpper = name ? name.toUpperCase() : '';
    const seatUpper = seat ? seat.toUpperCase() : '';
    
    if (flightUpper.startsWith('SQ')) {
        if (nameUpper) {
            for (const key in approvedEntriesCache) {
                const entry = approvedEntriesCache[key];
                
                if (entry.date !== date) continue;
                if (entry.flight !== flightUpper) continue;
                if (entry.name !== nameUpper) continue;
                
                return { 
                    isDuplicate: true, 
                    message: `${name} is already approved for flight ${flight} today`
                };
            }
        }
        return { isDuplicate: false };
    }
    
    const seatKey = `${date}_${flightUpper}_${seatUpper}`;
    if (approvedEntriesCache[seatKey]) {
        return { 
            isDuplicate: true, 
            message: `Seat ${seat} is already approved for flight ${flight}`
        };
    }
    
    return { isDuplicate: false };
}

// ----- Clear input fields -----
function clearInputFields() {
    nameInput.value = '';
    pnrInput.value = '';
    flightInput.value = '';
    airlineSelect.value = '';
    seatInput.value = '';
    classInput.value = '';
    numPaxInput.value = '1';
    fqtvInput.value = '';
    serialInput.value = '';
    remarksInput.value = '';
    qrStatus.innerHTML = '';
    seatWarning.style.display = 'none';
    
    // Reset last values
    lastSeatValue = '';
    lastPaxValue = '1';
    
    clearNotification.classList.add('show');
    setTimeout(() => {
        clearNotification.classList.remove('show');
    }, 3000);
}

// ----- Check if FQTV is required -----
function isFqtvRequired(classValue, fqtvValue) {
    return classValue && classValue.toUpperCase() === 'Y' && 
          (!fqtvValue || fqtvValue.trim() === '');
}

// ----- Duplicate Entry Check -----
function isDuplicateEntry(entry) {
    const data = JSON.parse(localStorage.getItem('codesData') || '[]');
    const flightUpper = entry.flight.toUpperCase();
    const nameUpper = entry.name.toUpperCase();
    const seatUpper = entry.seat.toUpperCase();
    
    if (flightUpper.startsWith('SQ')) {
        return data.some(existingEntry => 
            existingEntry.date === currentShiftDate && 
            existingEntry.flight.toUpperCase() === flightUpper && 
            existingEntry.name.toUpperCase() === nameUpper &&
            !existingEntry.approved
        );
    }
    
    return data.some(existingEntry => 
        existingEntry.date === currentShiftDate && 
        existingEntry.flight.toUpperCase() === flightUpper && 
        existingEntry.name.toUpperCase() === nameUpper &&
        existingEntry.seat.toUpperCase() === seatUpper &&
        !existingEntry.approved
    );
}

// ----- Save Entry -----
async function saveEntry(entry){
    if (!currentShiftType || currentShiftStatus !== 'open') {
        showAlert('No active shift or shift not open!', true);
        return;
    }
    
    entry.date = currentShiftDate;
    entry.shift = currentShiftType;
    
    // Auto-correct seat for restricted airlines
    if (isPaxRestrictedAirline(entry.flight)) {
        const correctedSeat = autoCorrectSeatForRestrictedAirline(entry.flight, entry.seat);
        if (correctedSeat !== entry.seat) {
            entry.seat = correctedSeat;
            seatInput.value = correctedSeat;
        }
    }
    
    // Validate seat-pax match
    const seatPaxValidation = validateSeatPaxMatch(entry.seat, entry.numPax);
    if (!seatPaxValidation.isValid) {
        showAlert(`Cannot save: ${seatPaxValidation.message}`, true);
        // Auto-correct pax
        entry.numPax = seatPaxValidation.calculatedPax;
        numPaxInput.value = seatPaxValidation.calculatedPax;
        showAlert(`Pax auto-corrected to ${seatPaxValidation.calculatedPax} based on seat ${entry.seat}`, false, false, true);
    }
    
    // Check for restricted airlines
    if (isPaxRestrictedAirline(entry.flight)) {
        if (entry.numPax !== 1) {
            showAlert(`Flight ${entry.flight} (${entry.flight.substring(0, 2)}) allows only 1 passenger per seat. Pax changed to 1.`, false, true);
            entry.numPax = 1;
            numPaxInput.value = '1';
        }
    }
    
    // Validate pax count
    const paxValidation = validatePaxCount(entry.flight, entry.seat, entry.numPax);
    if (!paxValidation.isValid) {
        showAlert(`Cannot save: ${paxValidation.message}`, true);
        return;
    }
    
    if (isDuplicateEntry(entry)) {
        console.log('Duplicate passenger detected, skipping save');
        showAlert(`${entry.name} is already entered for flight ${entry.flight}`, true);
        
        codeInput.value = '';
        codeInput.focus();
        setTimeout(clearInputFields, 2000);
        return;
    }
    
    const flightUpper = entry.flight.toUpperCase();
    const isQRFlight = flightUpper.startsWith('QR');
    
    let qrSaved = false;
    if (isQRFlight) {
        try {
            qrSaved = await saveToQRSystem(entry.code);
            if (qrSaved) {
                console.log('âœ… QR data saved successfully');
            }
        } catch (error) {
            console.error('âŒ Error saving QR data:', error);
        }
    }
    
    let data = JSON.parse(localStorage.getItem('codesData')||'[]');
    data.push(entry);
    localStorage.setItem('codesData', JSON.stringify(data));
    
    if (!renderTimeout) {
        renderTimeout = setTimeout(() => {
            renderEntries();
            renderTimeout = null;
        }, 50);
    }

    if (isQRFlight && qrSaved) {
        showAlert(`Entry saved! ${entry.name} - QR data saved to both systems`, false);
    } else if (isQRFlight && !qrSaved) {
        showAlert(`Entry saved! ${entry.name} - QR system save failed`, true);
    } else {
        showAlert(`Entry saved! ${entry.name}`);
    }

    codeInput.value = '';
    codeInput.focus();
    setTimeout(clearInputFields, 2000);
}

// ----- Optimized Render Function -----
async function renderEntries() {
    if (isRendering) {
        clearTimeout(renderTimeout);
        renderTimeout = setTimeout(renderEntries, 100);
        return;
    }
    
    isRendering = true;
    
    try {
        const data = JSON.parse(localStorage.getItem('codesData') || '[]').filter(e => !e.approved);
        const dataString = JSON.stringify(data);
        
        if (dataString === lastRenderData && entriesList.children.length > 0) {
            isRendering = false;
            return;
        }
        
        lastRenderData = dataString;
        entriesCount.textContent = `${data.length} entries`;
        
        entriesList.innerHTML = '';
        
        const fragment = document.createDocumentFragment();
        
        for (const [i, e] of data.entries()) {
            const tr = document.createElement('tr');
            
            const isFqtvNeeded = isFqtvRequired(e.class, e.fqtv);
            const isQRFlight = e.flight.toUpperCase().startsWith('QR');
            const isDelayEntry = e.isDelayCharge || false;
            const isSQFlight = e.flight.toUpperCase().startsWith('SQ');
            
            // Check for seat-pax mismatch
            const seatPaxValidation = validateSeatPaxMatch(e.seat, e.numPax);
            if (!seatPaxValidation.isValid) {
                tr.classList.add('seat-pax-mismatch');
            }
            
            if (isFqtvNeeded) {
                tr.classList.add('fqtv-required');
            }
            
            if (isDelayEntry) {
                tr.classList.add('delay-entry');
            }
            
            if (isSQFlight) {
                tr.classList.add('sq-flight');
            }
            
            let fqtvDisplay = e.fqtv || '';
            if (isFqtvNeeded && !fqtvDisplay) {
                fqtvDisplay = '<span class="fqtv-warning">FQTV REQUIRED </span>';
            }
            
            // REMOVED: FQTV Zoom button - only approve and delete buttons
            const approveBtn = document.createElement('button');
            approveBtn.className = 'action-btn';
            approveBtn.innerHTML = '<i class="fas fa-check-circle"></i> Approve';
            approveBtn.onclick = (function(index) {
                return function(event) {
                    event.stopPropagation();
                    event.preventDefault();
                    approveEntry(index);
                };
            })(i);
            
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'action-btn';
            deleteBtn.innerHTML = '<i class="fas fa-trash"></i> Delete';
            deleteBtn.onclick = (function(index) {
                return function(event) {
                    event.stopPropagation();
                    event.preventDefault();
                    deleteEntry(index);
                };
            })(i);
            
            const actionsCell = document.createElement('td');
            actionsCell.appendChild(approveBtn);
            actionsCell.appendChild(deleteBtn); // Only approve and delete buttons
            
            // Don't add QR or DELAY to flight number
            let flightDisplay = escapeHtml(e.flight);
            
            tr.innerHTML = `
                <td class="editable-cell" contenteditable="true" data-field="name">${escapeHtml(e.name)}</td>
                <td class="editable-cell" contenteditable="true" data-field="flight">${flightDisplay}</td>
                <td class="editable-cell" contenteditable="true" data-field="seat">${escapeHtml(e.seat)}</td>
                <td class="editable-cell" contenteditable="true" data-field="class">${escapeHtml(e.class || '')}</td>
                <td class="editable-cell fqtv-field-zoom" contenteditable="true" data-field="fqtv" style="position: relative;">
                    ${isFqtvNeeded && !e.fqtv ? '<span class="fqtv-warning">FQTV REQUIRED </span>' : escapeHtml(e.fqtv || '')}
                </td>
                <td class="editable-cell" contenteditable="true" data-field="numPax">${e.numPax}</td>
                <td class="editable-cell" contenteditable="true" data-field="serial">${escapeHtml(e.serial)}</td>
                <td class="editable-cell" contenteditable="true" data-field="remarks">${escapeHtml(e.remarks)}</td>
                <td class="editable-cell" contenteditable="true" data-field="pnr">${escapeHtml(e.pnr)}</td>
                <td>${formatDateForDisplay(e.date)}</td>
                <td>${e.shift || currentShiftType || '-'}</td>
            `;
            
            tr.appendChild(actionsCell);
            fragment.appendChild(tr);
        }
        
        entriesList.appendChild(fragment);
        addAutoSaveListeners();
        addSQFlightClickListeners();
        addFqtvZoomListeners();
        
    } catch (error) {
        console.error('Error rendering entries:', error);
    } finally {
        isRendering = false;
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function addAutoSaveListeners() {
    const editableCells = document.querySelectorAll('.editable-cell');
    editableCells.forEach(cell => {
        // Remove existing blur listeners
        cell.removeEventListener('blur', handleCellBlur);
        
        // Add new blur listener
        cell.addEventListener('blur', handleCellBlur);
    });
}

function handleCellBlur() {
    const cell = this;
    const field = cell.getAttribute('data-field');
    const row = cell.closest('tr');
    const rowIndex = Array.from(row.parentNode.children).indexOf(row);
    
    // Don't auto-save FQTV field on blur (we use the zoom modal for that)
    if (field === 'fqtv') {
        return;
    }
    
    // For other fields, save normally
    saveEditedEntry(rowIndex);
    
    // If seat or flight was changed, show validation message
    const cellIndex = Array.from(row.cells).indexOf(cell);
    if (cellIndex === 1 || cellIndex === 2 || cellIndex === 5) { // flight, seat, or pax
        const data = JSON.parse(localStorage.getItem('codesData')||'[]');
        const entry = data[rowIndex];
        
        if (entry) {
            // Auto-correct seat for restricted airlines
            if (cellIndex === 2 && isPaxRestrictedAirline(entry.flight)) {
                const correctedSeat = autoCorrectSeatForRestrictedAirline(entry.flight, entry.seat);
                if (correctedSeat !== entry.seat) {
                    entry.seat = correctedSeat;
                    row.cells[2].textContent = correctedSeat;
                    localStorage.setItem('codesData', JSON.stringify(data));
                }
            }
            
            // Re-check seat-pax match
            const seatPaxValidation = validateSeatPaxMatch(entry.seat, entry.numPax);
            if (!seatPaxValidation.isValid) {
                showAlert(seatPaxValidation.message, true);
                // Update row styling
                row.classList.add('seat-pax-mismatch');
            } else {
                row.classList.remove('seat-pax-mismatch');
            }
            
            // Also check restricted airlines
            if (isPaxRestrictedAirline(entry.flight) && entry.numPax !== 1) {
                showAlert(`Flight ${entry.flight} allows only 1 passenger. Pax changed to 1.`, false, true);
                entry.numPax = 1;
                row.cells[5].textContent = '1';
                localStorage.setItem('codesData', JSON.stringify(data));
            }
        }
    }
}

function addFqtvZoomListeners() {
    const fqtvCells = document.querySelectorAll('.editable-cell.fqtv-field-zoom');
    fqtvCells.forEach((cell, index) => {
        // Remove existing listeners
        cell.removeEventListener('click', handleFqtvCellClick);
        // Add new listener
        cell.addEventListener('click', handleFqtvCellClick);
    });
}

function addSQFlightClickListeners() {
    const sqFlights = document.querySelectorAll('.sq-flight td:first-child');
    sqFlights.forEach((cell, index) => {
        // Remove existing listeners
        cell.removeEventListener('click', handleSQNameClick);
        // Add new listener
        cell.addEventListener('click', handleSQNameClick);
    });
}

function handleSQNameClick(event) {
    const cell = event.target;
    const row = cell.closest('tr');
    const rowIndex = Array.from(row.parentNode.children).indexOf(row);
    
    if (rowIndex >= 0) {
        const data = JSON.parse(localStorage.getItem('codesData') || '[]');
        const entry = data[rowIndex];
        
        if (entry && entry.flight.toUpperCase().startsWith('SQ')) {
            openNumericKeyboard(rowIndex, cell.textContent);
        }
    }
}

function openNumericKeyboard(rowIndex, currentValue) {
    currentEditingRowIndex = rowIndex;
    currentEditingField = 'name';
    
    // Try to extract numeric value from current name
    const numericMatch = currentValue.match(/\d+/);
    if (numericMatch) {
        currentNumericValue = numericMatch[0];
    } else {
        currentNumericValue = '0';
    }
    
    numericDisplay.textContent = currentNumericValue;
    numericKeyboardModal.classList.add('show');
    
    // Focus the modal
    setTimeout(() => {
        numericDisplay.focus();
    }, 100);
}

function saveEditedEntry(rowIndex) {
    const data = JSON.parse(localStorage.getItem('codesData')||'[]');
    const entry = data[rowIndex];
    
    if (!entry) return;
    
    const rows = entriesList.querySelectorAll('tr');
    const targetRow = rows[rowIndex];
    
    if (!targetRow) return;
    
    // Get updated values
    const updatedName = targetRow.cells[0].textContent.trim();
    const updatedFlight = targetRow.cells[1].textContent.trim();
    const updatedSeat = targetRow.cells[2].textContent.trim();
    const updatedClass = targetRow.cells[3].textContent.trim();
    
    let fqtvValue = targetRow.cells[4].textContent.trim();
    fqtvValue = fqtvValue.replace('FQTV REQUIRED', '').trim();
    const updatedFqtv = fqtvValue;
    
    const updatedNumPax = Number(targetRow.cells[5].textContent.trim()) || 0;
    const updatedSerial = targetRow.cells[6].textContent.trim();
    const updatedRemarks = targetRow.cells[7].textContent.trim();
    const updatedPnr = targetRow.cells[8].textContent.trim();
    
    // Check if seat or flight was changed
    const seatChanged = entry.seat !== updatedSeat;
    const flightChanged = entry.flight !== updatedFlight;
    
    // Update entry
    entry.name = updatedName;
    entry.flight = updatedFlight;
    
    // Auto-correct seat for restricted airlines
    if (isPaxRestrictedAirline(updatedFlight)) {
        entry.seat = autoCorrectSeatForRestrictedAirline(updatedFlight, updatedSeat);
        targetRow.cells[2].textContent = entry.seat;
    } else {
        entry.seat = updatedSeat;
    }
    
    entry.class = updatedClass;
    entry.fqtv = updatedFqtv;
    entry.serial = updatedSerial;
    entry.remarks = updatedRemarks;
    entry.pnr = updatedPnr;
    
    // Handle seat-pax validation
    const seatPaxValidation = validateSeatPaxMatch(entry.seat, updatedNumPax);
    if (!seatPaxValidation.isValid) {
        // Auto-correct pax based on seat
        entry.numPax = seatPaxValidation.calculatedPax;
        targetRow.cells[5].textContent = seatPaxValidation.calculatedPax;
        showAlert(`Pax auto-corrected to ${seatPaxValidation.calculatedPax} based on seat ${entry.seat}`, false, false, true);
    } else {
        entry.numPax = updatedNumPax;
    }
    
    // Handle restricted airlines
    if (isPaxRestrictedAirline(updatedFlight) && entry.numPax !== 1) {
        entry.numPax = 1;
        targetRow.cells[5].textContent = '1';
        showAlert(`Flight ${updatedFlight} (${updatedFlight.substring(0, 2)}) allows only 1 passenger. Pax changed to 1.`, false, true);
    }
    
    localStorage.setItem('codesData', JSON.stringify(data));
    
    console.log("Entry saved:", {
        name: entry.name,
        flight: entry.flight,
        seat: entry.seat,
        pax: entry.numPax,
        restricted: isPaxRestrictedAirline(entry.flight),
        seatPaxMatch: seatPaxValidation.isValid
    });
}

// ----- Numeric Keyboard Functions -----
function initializeNumericKeyboard() {
    // Add event listeners to numeric keys
    document.querySelectorAll('.numeric-key[data-value]').forEach(key => {
        key.addEventListener('click', () => {
            const value = key.getAttribute('data-value');
            handleNumericInput(value);
        });
    });
    
    // Backspace key
    backspaceKey.addEventListener('click', () => {
        handleBackspace();
    });
    
    // Clear key
    clearKey.addEventListener('click', () => {
        handleClear();
    });
    
    // Apply button
    applyNumericBtn.addEventListener('click', () => {
        applyNumericValue();
    });
    
    // Close button
    closeNumericBtn.addEventListener('click', () => {
        closeNumericKeyboard();
    });
    
    // Close modal button
    closeNumericKeyboardBtn.addEventListener('click', () => {
        closeNumericKeyboard();
    });
    
    // Close modal when clicking outside
    numericKeyboardModal.addEventListener('click', (e) => {
        if (e.target === numericKeyboardModal) {
            closeNumericKeyboard();
        }
    });
    
    // Keyboard support
    document.addEventListener('keydown', (e) => {
        if (numericKeyboardModal.classList.contains('show')) {
            if (e.key >= '0' && e.key <= '9') {
                handleNumericInput(e.key);
            } else if (e.key === 'Backspace') {
                handleBackspace();
                e.preventDefault();
            } else if (e.key === 'Enter') {
                applyNumericValue();
                e.preventDefault();
            } else if (e.key === 'Escape') {
                closeNumericKeyboard();
                e.preventDefault();
            }
        }
    });
}

function handleNumericInput(value) {
    if (currentNumericValue === '0') {
        currentNumericValue = value;
    } else {
        currentNumericValue += value;
    }
    numericDisplay.textContent = currentNumericValue;
}

function handleBackspace() {
    if (currentNumericValue.length > 1) {
        currentNumericValue = currentNumericValue.slice(0, -1);
    } else {
        currentNumericValue = '0';
    }
    numericDisplay.textContent = currentNumericValue;
}

function handleClear() {
    currentNumericValue = '0';
    numericDisplay.textContent = currentNumericValue;
}

function applyNumericValue() {
    if (currentEditingRowIndex >= 0 && currentEditingField) {
        const data = JSON.parse(localStorage.getItem('codesData')||'[]');
        const entry = data[currentEditingRowIndex];
        
        if (entry) {
            if (currentEditingField === 'name') {
                // For SQ flights, we want to replace the name with just the number
                entry.name = currentNumericValue;
                
                // Update the table cell
                const rows = entriesList.querySelectorAll('tr');
                if (rows[currentEditingRowIndex]) {
                    rows[currentEditingRowIndex].cells[0].textContent = currentNumericValue;
                }
                
                localStorage.setItem('codesData', JSON.stringify(data));
                showAlert(`Name updated to number: ${currentNumericValue}`, false);
            }
        }
    }
    
    closeNumericKeyboard();
}

function closeNumericKeyboard() {
    numericKeyboardModal.classList.remove('show');
    currentEditingRowIndex = -1;
    currentEditingField = '';
    currentNumericValue = '0';
}

// ----- Delete Entry -----
function deleteEntry(index) {
    if (isApproving) {
        return;
    }
    
    let data = JSON.parse(localStorage.getItem('codesData')||'[]');
    
    if (index >= 0 && index < data.length) {
        data.splice(index, 1);
        localStorage.setItem('codesData', JSON.stringify(data));
        renderEntries();
        showAlert('Entry deleted successfully!');
    }
}

// ----- Barcode Scanner Detection -----
function handleScannerInput() {
    if (isProcessing) return;
    
    const currentValue = codeInput.value;
    
    if (currentValue.length > lastValue.length + 5) {
        isScannerActive = true;
        scannerIndicator.classList.add('show');
        
        clearTimeout(scannerTimer);
        scannerTimer = setTimeout(() => {
            processScannerInput();
        }, 100);
    } 
    else if (currentValue !== lastValue) {
        if (isScannerActive) {
            isScannerActive = false;
            scannerIndicator.classList.remove('show');
        }
        
        clearTimeout(scannerTimer);
        scannerTimer = setTimeout(() => {
            processManualInput();
        }, 800);
    }
    
    lastValue = currentValue;
}

function processScannerInput() {
    if (isProcessing) return;
    isProcessing = true;
    
    scannerIndicator.classList.remove('show');
    isScannerActive = false;
    
    parseCode();
    const entry = {
        date: currentShiftDate,
        user: userDisplay.textContent,
        shift: currentShiftType,
        code: codeInput.value,
        name: nameInput.value,
        pnr: pnrInput.value,
        flight: flightInput.value,
        airline: airlineSelect.value,
        seat: seatInput.value,
        class: classInput.value,
        serial: serialInput.value,
        remarks: remarksInput.value,
        fqtv: fqtvInput.value,
        numPax: parseInt(numPaxInput.value) || 0, // FIXED: Use parseInt and allow 0
        approved: false
    };
    saveEntry(entry);
    
    setTimeout(() => {
        isProcessing = false;
    }, 1000);
}

function processManualInput() {
    if (isProcessing) return;
    isProcessing = true;
    
    parseCode();
    const entry = {
        date: currentShiftDate,
        user: userDisplay.textContent,
        shift: currentShiftType,
        code: codeInput.value,
        name: nameInput.value,
        pnr: pnrInput.value,
        flight: flightInput.value,
        airline: airlineSelect.value,
        seat: seatInput.value,
        class: classInput.value,
        serial: serialInput.value,
        remarks: remarksInput.value,
        fqtv: fqtvInput.value,
        numPax: parseInt(numPaxInput.value) || 0, // FIXED: Use parseInt and allow 0
        approved: false
    };
    saveEntry(entry);
    
    setTimeout(() => {
        isProcessing = false;
    }, 1000);
}

function handleFieldExit() {
    if (isProcessing) return;
    
    const code = codeInput.value.trim();
    if (code) {
        parseCode();
        if (nameInput.value && flightInput.value) {
            isProcessing = true;
            const entry = {
                date: currentShiftDate,
                user: userDisplay.textContent,
                shift: currentShiftType,
                code: codeInput.value,
                name: nameInput.value,
                pnr: pnrInput.value,
                flight: flightInput.value,
                airline: airlineSelect.value,
                seat: seatInput.value,
                class: classInput.value,
                serial: serialInput.value,
                remarks: remarksInput.value,
                fqtv: fqtvInput.value,
                numPax: parseInt(numPaxInput.value) || 0, // FIXED: Use parseInt and allow 0
                approved: false
            };
            saveEntry(entry);
            
            setTimeout(() => {
                isProcessing = false;
            }, 1000);
        }
    }
}

// ----- DELAY CHARGE FUNCTIONS -----

// ----- Calculate Delay Charge -----
function calculateDelayCharge(entryTime, exitTime, stdTime, numPax) {
    const [entryHour, entryMin] = entryTime.split(':').map(Number);
    const [exitHour, exitMin] = exitTime.split(':').map(Number);
    const [stdHour, stdMin] = stdTime.split(':').map(Number);
    
    const entryTotalMinutes = entryHour * 60 + entryMin;
    const exitTotalMinutes = exitHour * 60 + exitMin;
    const stdTotalMinutes = stdHour * 60 + stdMin;
    
    let totalStayMinutes = exitTotalMinutes - entryTotalMinutes;
    
    if (totalStayMinutes < 0) {
        totalStayMinutes += 24 * 60;
    }
    
    const totalStayHours = Math.floor(totalStayMinutes / 60);
    const remainingMinutes = totalStayMinutes % 60;
    
    let lateDepartureMinutes = 0;
    if (exitTotalMinutes > stdTotalMinutes) {
        lateDepartureMinutes = exitTotalMinutes - stdTotalMinutes;
    }
    
    let chargeableHours = 0;
    if (totalStayMinutes > FREE_HOURS * 60) {
        const exceedMinutes = totalStayMinutes - (FREE_HOURS * 60);
        chargeableHours = Math.floor(exceedMinutes / 60);
    }
    
    const totalCharge = 0;
    
    return {
        totalStayMinutes,
        totalStayHours,
        remainingMinutes,
        lateDepartureMinutes,
        chargeableHours,
        totalCharge,
        chargePerPax: 0
    };
}

// ----- Show Delay Charge Modal -----
function showDelayChargeModal() {
    if (!currentShiftType || currentShiftStatus !== 'open') {
        showAlert('No active shift or shift not open!', true);
        return;
    }
    
    delayFlightInput.value = '';
    entryTimeInput.value = '00:00';
    exitTimeInput.value = '00:00';
    stdTimeInput.value = '00:00';
    delayPaxInput.value = '1';
    delayCalcResult.style.display = 'none';
    
    const currentTime = getCurrentTime();
    entryTimeInput.value = currentTime;
    exitTimeInput.value = currentTime;
    
    delayChargeModal.classList.add('show');
    
    setTimeout(() => {
        delayFlightInput.focus();
    }, 100);
}

// ----- Calculate Delay Button Handler -----
function handleCalculateDelay() {
    const flightNo = delayFlightInput.value.trim();
    const entryTime = entryTimeInput.value;
    const exitTime = exitTimeInput.value;
    const stdTime = stdTimeInput.value;
    const numPax = parseInt(delayPaxInput.value) || 1;
    
    if (!flightNo) {
        showAlert('Please enter flight number', true);
        delayFlightInput.focus();
        return;
    }
    
    if (!entryTime || !exitTime || !stdTime) {
        showAlert('Please enter all time fields', true);
        return;
    }
    
    if (entryTime === '00:00' || exitTime === '00:00' || stdTime === '00:00') {
        showAlert('Please set proper time values', true);
        return;
    }
    
    const calculation = calculateDelayCharge(entryTime, exitTime, stdTime, numPax);
    
    delayCalcResult.style.display = 'block';
    
    if (calculation.chargeableHours > 0) {
        delayCalcDetails.innerHTML = `
            <p><strong>Flight:</strong> ${flightNo.toUpperCase()}</p>
            <p><strong>Total Stay:</strong> ${calculation.totalStayHours}h ${calculation.remainingMinutes}m</p>
            <p><strong>Free Hours:</strong> ${FREE_HOURS}h</p>
            <p><strong>Chargeable Hours:</strong> ${calculation.chargeableHours}h (complete hours only)</p>
            <p><strong>Number of Pax:</strong> ${numPax}</p>
            <p><strong>Remarks to be saved:</strong> <em>"Delay charges for ${numPax} pax for ${calculation.chargeableHours} hour(s)"</em></p>
            <p><strong>Total Charge:</strong> <span class="delay-amount">$${calculation.totalCharge.toFixed(2)}</span></p>
        `;
    } else {
        delayCalcDetails.innerHTML = `
            <p><strong>Flight:</strong> ${flightNo.toUpperCase()}</p>
            <p><strong>Total Stay:</strong> ${calculation.totalStayHours}h ${calculation.remainingMinutes}m</p>
            <p><strong>Free Hours:</strong> ${FREE_HOURS}h</p>
            <p><strong>Chargeable Hours:</strong> ${calculation.chargeableHours}h</p>
            <p><strong>Status:</strong> <span class="no-charge">No Charge - Within ${FREE_HOURS}h free period</span></p>
        `;
    }
}

// ----- Save Delay Charge Entry -----
async function saveDelayChargeEntry() {
    const flightNo = delayFlightInput.value.trim().toUpperCase();
    const entryTime = entryTimeInput.value;
    const exitTime = exitTimeInput.value;
    const stdTime = stdTimeInput.value;
    const numPax = parseInt(delayPaxInput.value) || 1;
    
    // Validate inputs
    if (!flightNo) {
        showAlert('Please enter flight number', true);
        delayFlightInput.focus();
        return;
    }
    
    if (!entryTime || !exitTime || !stdTime) {
        showAlert('Please enter all time fields', true);
        return;
    }
    
    if (entryTime === '00:00' || exitTime === '00:00' || stdTime === '00:00') {
        showAlert('Please set proper time values', true);
        return;
    }
    
    // Calculate delay charge
    const calculation = calculateDelayCharge(entryTime, exitTime, stdTime, numPax);
    
    // Generate remarks as requested: "Delay charges for X pax for Y hour(s)"
    let remarks = `Delay charges for ${numPax} pax for ${calculation.chargeableHours} hour(s)`;
    
    // Create delay charge entry with corrections:
    const delayEntry = {
        date: currentShiftDate,
        user: userDisplay.textContent,
        shift: currentShiftType,
        code: 'DELAY_CHARGE',
        name: 'DELAY CHARGE',
        pnr: 'DELAY',
        flight: flightNo, // JUST THE FLIGHT NUMBER, NO "DELAY" TEXT
        airline: flightNo.substring(0, 2),
        seat: '', // EMPTY SEAT
        class: 'J', // CLASS SET TO "J"
        serial: '', // EMPTY SERIAL
        remarks: remarks,
        fqtv: '',
        numPax: 0, // SET TO 0 AS REQUESTED - FIXED
        approved: false,
        isDelayCharge: true,
        delayDetails: {
            entryTime: entryTime,
            exitTime: exitTime,
            stdTime: stdTime,
            totalStayMinutes: calculation.totalStayMinutes,
            totalStayHours: calculation.totalStayHours,
            remainingMinutes: calculation.remainingMinutes,
            chargeableHours: calculation.chargeableHours,
            totalCharge: calculation.totalCharge,
            calculatedAt: getMaldivesDateTimeISO()
        }
    };
    
    // Save the entry
    let data = JSON.parse(localStorage.getItem('codesData')||'[]');
    data.push(delayEntry);
    localStorage.setItem('codesData', JSON.stringify(data));
    
    // Close modal
    delayChargeModal.classList.remove('show');
    
    // Show success message
    showAlert(`Delay charge entry saved for flight ${flightNo}`, false);
    
    // Render entries
    renderEntries();
    
    // Reset form
    delayFlightInput.value = '';
    entryTimeInput.value = '00:00';
    exitTimeInput.value = '00:00';
    stdTimeInput.value = '00:00';
    delayPaxInput.value = '1';
    delayCalcResult.style.display = 'none';
}

// ----- LOCAL STORAGE MANAGEMENT FUNCTIONS -----

// Show Local Storage Modal
function showLocalStorageModal() {
    loadStorageData();
    localStorageModal.classList.add('show');
}

// Load and display storage data
function loadStorageData() {
    const allKeys = Object.keys(localStorage);
    const storageStats = document.getElementById('storageStats');
    const storageTabs = document.getElementById('storageTabs');
    const allStoragePanel = document.getElementById('allStoragePanel');
    
    let totalSize = 0;
    allKeys.forEach(key => {
        const value = localStorage.getItem(key);
        totalSize += (key.length + value.length) * 2;
    });
    
    storageStats.innerHTML = `
        <div class="storage-stat-item">
            <div class="storage-stat-value">${allKeys.length}</div>
            <div class="storage-stat-label">Total Items</div>
        </div>
        <div class="storage-stat-item">
            <div class="storage-stat-value">${(totalSize / 1024).toFixed(2)} KB</div>
            <div class="storage-stat-label">Total Size</div>
        </div>
        <div class="storage-stat-item">
            <div class="storage-stat-value">${(localStorage.length / 5000 * 100).toFixed(1)}%</div>
            <div class="storage-stat-label">Capacity Used</div>
        </div>
    `;
    
    storageTabs.innerHTML = '';
    
    const allTab = document.createElement('button');
    allTab.className = 'storage-tab active';
    allTab.textContent = 'All Items';
    allTab.onclick = () => showStorageTab('all', allTab);
    storageTabs.appendChild(allTab);
    
    const categories = {
        'codesData': 'Pending Entries',
        'approvedLocalData': 'Approved Entries (Local)',
        'qrProcessedCodes': 'QR Processed Codes',
        'localQRData': 'Local QR Data',
        'approvedEntriesCache': 'Approved Cache',
        'currentShiftInfo': 'Shift Info',
        'loggedInUser': 'User Data'
    };
    
    Object.keys(categories).forEach(categoryKey => {
        if (localStorage.getItem(categoryKey)) {
            const tab = document.createElement('button');
            tab.className = 'storage-tab';
            tab.textContent = categories[categoryKey];
            tab.dataset.key = categoryKey;
            tab.onclick = () => showStorageTab(categoryKey, tab);
            storageTabs.appendChild(tab);
        }
    });
    
    const otherKeys = allKeys.filter(key => !Object.keys(categories).includes(key));
    if (otherKeys.length > 0) {
        const otherTab = document.createElement('button');
        otherTab.className = 'storage-tab';
        otherTab.textContent = `Other (${otherKeys.length})`;
        otherTab.dataset.key = 'other';
        otherTab.onclick = () => showStorageTab('other', otherTab);
        storageTabs.appendChild(otherTab);
    }
    
    displayStorageItems('all', allKeys, allStoragePanel);
    
    showStorageTab('all', allTab);
}

// Display storage items in a panel
function displayStorageItems(category, keys, panel) {
    panel.innerHTML = '';
    
    if (keys.length === 0) {
        panel.innerHTML = '<div class="empty-storage">No data found in this category</div>';
        return;
    }
    
    if (category === 'approvedLocalData') {
        displayApprovedEntries(panel);
        return;
    }
    
    keys.forEach(key => {
        try {
            const value = localStorage.getItem(key);
            const itemSize = (key.length + value.length) * 2;
            let parsedValue;
            let isJson = false;
            
            try {
                parsedValue = JSON.parse(value);
                isJson = true;
            } catch (e) {
                parsedValue = value;
            }
            
            const valueStr = isJson ? JSON.stringify(parsedValue, null, 2) : value;
            
            const itemDiv = document.createElement('div');
            itemDiv.className = 'storage-data-item';
            itemDiv.innerHTML = `
                <div class="storage-data-header">
                    <span class="storage-key">${key}</span>
                    <span class="storage-size">${(itemSize / 1024).toFixed(2)} KB</span>
                </div>
                <div class="storage-value">${isJson ? 'JSON Data - ' : ''}${valueStr.length > 500 ? valueStr.substring(0, 500) + '...' : valueStr}</div>
                <div style="margin-top: 8px; display: flex; gap: 5px;">
                    ${isJson ? `<button class="view-json-btn" onclick="viewJson('${key}', ${JSON.stringify(parsedValue)})">View JSON</button>` : ''}
                    <button class="action-btn" onclick="deleteStorageItem('${key}')" style="padding: 3px 8px; font-size: 11px;">
                        <i class="fas fa-trash"></i> Delete
                    </button>
                    <button class="action-btn" onclick="copyStorageItem('${key}')" style="padding: 3px 8px; font-size: 11px;">
                        <i class="fas fa-copy"></i> Copy
                    </button>
                </div>
            `;
            
            panel.appendChild(itemDiv);
        } catch (error) {
            console.error(`Error processing key ${key}:`, error);
        }
    });
}

// Display approved entries in a table
function displayApprovedEntries(panel) {
    try {
        const approvedLocalData = JSON.parse(localStorage.getItem('approvedLocalData') || '[]');
        
        if (approvedLocalData.length === 0) {
            panel.innerHTML = '<div class="empty-storage">No approved entries found in local storage</div>';
            return;
        }
        
        const table = document.createElement('table');
        table.className = 'approved-entries-table';
        table.innerHTML = `
            <thead>
                <tr>
                    <th>Name</th>
                    <th>Flight</th>
                    <th>Seat</th>
                    <th>Class</th>
                    <th>FQTV</th>
                    <th>Pax</th>
                    <th>Serial</th>
                    <th>PNR</th>
                    <th>Date</th>
                    <th>Shift</th>
                    <th>Synced</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                ${approvedLocalData.map((entry, index) => `
                    <tr>
                        <td>${escapeHtml(entry.name)}</td>
                        <td>${escapeHtml(entry.flightNo)}</td>
                        <td>${escapeHtml(entry.seatNo)}</td>
                        <td>${escapeHtml(entry.class)}</td>
                        <td>${escapeHtml(entry.fqtv || '')}</td>
                        <td>${entry.numPax}</td>
                        <td>${escapeHtml(entry.serial)}</td>
                        <td>${escapeHtml(entry.pnr || '')}</td>
                        <td>${formatDateForDisplay(entry.date)}</td>
                        <td>${entry.shift}</td>
                        <td>${entry.synced ? '<span style="color: var(--success);"><i class="fas fa-check-circle"></i> Yes</span>' : '<span style="color: var(--warning);"><i class="fas fa-clock"></i> Pending</span>'}</td>
                        <td>
                            <button class="action-btn" onclick="deleteApprovedEntry(${index})" style="padding: 3px 8px; font-size: 11px;">
                                <i class="fas fa-trash"></i> Delete
                            </button>
                            ${!entry.synced ? `
                                <button class="action-btn" onclick="syncApprovedEntry(${index})" style="padding: 3px 8px; font-size: 11px; background: var(--info);">
                                    <i class="fas fa-sync-alt"></i> Sync Now
                                </button>
                            ` : ''}
                        </td>
                    </tr>
                `).join('')}
            </tbody>
        `;
        
        panel.appendChild(table);
        
    } catch (error) {
        console.error('Error displaying approved entries:', error);
        panel.innerHTML = `<div class="empty-storage">Error loading approved entries: ${error.message}</div>`;
    }
}

// Delete approved entry
function deleteApprovedEntry(index) {
    if (confirm('Are you sure you want to delete this approved entry from local storage?\n\nThis will remove it from the local storage but won\'t affect Firebase if already synced.')) {
        try {
            const approvedLocalData = JSON.parse(localStorage.getItem('approvedLocalData') || '[]');
            const deletedEntry = approvedLocalData.splice(index, 1)[0];
            localStorage.setItem('approvedLocalData', JSON.stringify(approvedLocalData));
            
            // Also remove from cache
            if (deletedEntry.flightNo && deletedEntry.seatNo && deletedEntry.date) {
                const flightUpper = deletedEntry.flightNo.toUpperCase();
                const seatUpper = deletedEntry.seatNo.toUpperCase();
                const seatKey = `${deletedEntry.date}_${flightUpper}_${seatUpper}`;
                delete approvedEntriesCache[seatKey];
                localStorage.setItem('approvedEntriesCache', JSON.stringify(approvedEntriesCache));
            }
            
            showAlert('Approved entry deleted from local storage', false);
            loadStorageData();
            
        } catch (error) {
            console.error('Error deleting approved entry:', error);
            showAlert('Error deleting approved entry: ' + error.message, true);
        }
    }
}

// Sync approved entry manually
function syncApprovedEntry(index) {
    try {
        const approvedLocalData = JSON.parse(localStorage.getItem('approvedLocalData') || '[]');
        const entry = approvedLocalData[index];
        
        if (!entry) {
            showAlert('Entry not found', true);
            return;
        }
        
        if (entry.synced) {
            showAlert('Entry is already synced', true);
            return;
        }
        
        if (!window.passengerDb) {
            showAlert('Firebase connection not available', true);
            return;
        }
        
        showAlert('Syncing entry to Firebase...', false, false, true);
        
        // Remove local-only fields before saving to Firebase
        const firebaseEntry = { ...entry };
        delete firebaseEntry.synced;
        delete firebaseEntry.syncedAt;
        delete firebaseEntry.localId;
        delete firebaseEntry.originalEntry;
        
        window.passengerDb.collection('passengers').doc(entry.docName).set(firebaseEntry)
            .then(() => {
                // Mark as synced in localStorage
                entry.synced = true;
                entry.syncedAt = getMaldivesDateTimeISO();
                localStorage.setItem('approvedLocalData', JSON.stringify(approvedLocalData));
                
                showAlert('Entry synced successfully to Firebase!', false);
                loadStorageData();
            })
            .catch(error => {
                console.error('Error syncing entry:', error);
                showAlert('Error syncing to Firebase: ' + error.message, true);
            });
        
    } catch (error) {
        console.error('Error syncing approved entry:', error);
        showAlert('Error syncing entry: ' + error.message, true);
    }
}

// Show specific storage tab
function showStorageTab(category, tabElement) {
    document.querySelectorAll('.storage-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    
    tabElement.classList.add('active');
    
    let panel = document.getElementById(`${category}Panel`);
    if (!panel) {
        panel = document.createElement('div');
        panel.id = `${category}Panel`;
        panel.className = 'storage-panel';
        document.querySelector('.storage-tab-content').appendChild(panel);
    }
    
    document.querySelectorAll('.storage-panel').forEach(p => {
        p.classList.remove('active');
    });
    
    panel.classList.add('active');
    
    const allKeys = Object.keys(localStorage);
    let filteredKeys = [];
    
    if (category === 'all') {
        filteredKeys = allKeys;
    } else if (category === 'other') {
        const categories = [
            'codesData', 'approvedLocalData', 'qrProcessedCodes', 
            'localQRData', 'approvedEntriesCache', 'currentShiftInfo', 
            'loggedInUser'
        ];
        filteredKeys = allKeys.filter(key => !categories.includes(key));
    } else {
        filteredKeys = allKeys.filter(key => key === category);
    }
    
    displayStorageItems(category, filteredKeys, panel);
}

// View JSON in modal
function viewJson(key, data) {
    jsonViewerTitle.textContent = `JSON Data: ${key}`;
    jsonViewerBody.textContent = JSON.stringify(data, null, 2);
    
    jsonViewerModal.classList.add('show');
}

// Copy storage item to clipboard
function copyStorageItem(key) {
    try {
        const value = localStorage.getItem(key);
        navigator.clipboard.writeText(value).then(() => {
            showAlert(`Copied "${key}" to clipboard`, false, false, true);
        }).catch(err => {
            showAlert(`Failed to copy: ${err}`, true);
        });
    } catch (error) {
        showAlert(`Error copying: ${error.message}`, true);
    }
}

// Delete a specific storage item
function deleteStorageItem(key) {
    if (confirm(`Are you sure you want to delete "${key}" from local storage?\n\nThis action cannot be undone.`)) {
        localStorage.removeItem(key);
        showAlert(`Deleted "${key}" from local storage`, false);
        loadStorageData();
    }
}

// Clear all local storage
function clearAllLocalStorage() {
    if (confirm('âš ï¸ WARNING: Are you absolutely sure you want to clear ALL local storage?\n\nThis will delete:\nâ€¢ All pending passenger entries\nâ€¢ All approved entries (including unsynced)\nâ€¢ QR processed codes\nâ€¢ Shift information\nâ€¢ User session\n\nThis action cannot be undone!')) {
        localStorage.clear();
        showAlert('All local storage cleared successfully', false);
        
        window.location.reload();
    }
}

// ----- Event Listeners -----
manualSaveBtn.addEventListener('click', async function() {
    if (isProcessing) return;
    isProcessing = true;
    
    parseCode();
    const entry = {
        date: currentShiftDate,
        user: userDisplay.textContent,
        shift: currentShiftType,
        code: codeInput.value,
        name: nameInput.value,
        pnr: pnrInput.value,
        flight: flightInput.value,
        airline: airlineSelect.value,
        seat: seatInput.value,
        class: classInput.value,
        serial: serialInput.value,
        remarks: remarksInput.value,
        fqtv: fqtvInput.value,
        numPax: parseInt(numPaxInput.value) || 0, // FIXED: Use parseInt and allow 0
        approved: false
    };
    
    // Auto-correct seat for restricted airlines
    if (isPaxRestrictedAirline(entry.flight)) {
        const correctedSeat = autoCorrectSeatForRestrictedAirline(entry.flight, entry.seat);
        if (correctedSeat !== entry.seat) {
            entry.seat = correctedSeat;
            seatInput.value = correctedSeat;
        }
    }
    
    // Validate seat-pax match
    const seatPaxValidation = validateSeatPaxMatch(entry.seat, entry.numPax);
    if (!seatPaxValidation.isValid) {
        showAlert(`Cannot save: ${seatPaxValidation.message}`, true);
        entry.numPax = seatPaxValidation.calculatedPax;
        numPaxInput.value = seatPaxValidation.calculatedPax;
        showAlert(`Pax auto-corrected to ${seatPaxValidation.calculatedPax} based on seat ${entry.seat}`, false, false, true);
    }
    
    // Check for restricted airlines
    if (isPaxRestrictedAirline(entry.flight)) {
        if (entry.numPax !== 1) {
            showAlert(`Flight ${entry.flight} (${entry.flight.substring(0, 2)}) allows only 1 passenger per seat. Pax changed to 1.`, false, true);
            entry.numPax = 1;
            numPaxInput.value = '1';
        }
    }
    
    await saveEntry(entry);
    
    setTimeout(() => {
        isProcessing = false;
    }, 1000);
});

// Zoom modal listeners
closeZoomBtn.addEventListener('click', closeZoomModal);
zoomCancelBtn.addEventListener('click', closeZoomModal);

// FQTV zoom modal listeners
closeFqtvZoomBtn.addEventListener('click', closeFqtvZoomModal);
fqtvZoomCancelBtn.addEventListener('click', closeFqtvZoomModal);

// Seat input listeners for real-time validation and auto-correction
seatInput.addEventListener('input', function() {
    const currentSeat = this.value.trim();
    const flightValue = flightInput.value.trim();
    
    if (currentSeat !== lastSeatValue) {
        // Auto-correct seat for restricted airlines
        if (flightValue && isPaxRestrictedAirline(flightValue)) {
            const correctedSeat = autoCorrectSeatForRestrictedAirline(flightValue, currentSeat);
            if (correctedSeat !== currentSeat) {
                this.value = correctedSeat;
            }
        }
        
        checkSeatPaxMatch();
        lastSeatValue = this.value.trim();
        
        // Auto-correct pax based on seat (only for non-restricted airlines)
        if (this.value.trim()) {
            if (!isPaxRestrictedAirline(flightValue)) {
                autoCorrectPaxFromSeat(this, numPaxInput);
            } else {
                // For restricted airlines, always set pax to 1
                numPaxInput.value = '1';
            }
        }
    }
});

// Pax input listener (FIXED: Only alert on changes)
numPaxInput.addEventListener('input', function() {
    const currentPax = this.value;
    if (currentPax !== lastPaxValue) {
        checkSeatPaxMatch();
        lastPaxValue = currentPax;
    }
});

// Flight input listener for auto-seat correction
flightInput.addEventListener('input', function() {
    const flightValue = this.value.trim();
    const seatValue = seatInput.value.trim();
    
    // Auto-select airline based on flight code
    if (this.value.length >= 2) {
        const iata = this.value.substring(0, 2).toUpperCase();
        if (airlines[iata]) {
            airlineSelect.value = iata;
        }
    }
    
    // Auto-correct seat if airline is restricted
    if (flightValue && seatValue && isPaxRestrictedAirline(flightValue)) {
        const correctedSeat = autoCorrectSeatForRestrictedAirline(flightValue, seatValue);
        if (correctedSeat !== seatValue) {
            seatInput.value = correctedSeat;
            showAlert(`Seat auto-corrected from "${seatValue}" to "${correctedSeat}" for restricted airline ${flightValue.substring(0, 2)}`, false, true);
        }
    }
    
    checkSeatPaxMatch();
});

zoomSeatInput.addEventListener('input', function() {
    const flightValue = zoomFlightInput.value.trim();
    const seatValue = this.value.trim();
    
    // Auto-correct seat for restricted airlines
    if (flightValue && isPaxRestrictedAirline(flightValue)) {
        const correctedSeat = autoCorrectSeatForRestrictedAirline(flightValue, seatValue);
        if (correctedSeat !== seatValue) {
            this.value = correctedSeat;
        }
    }
    
    checkZoomSeatPaxMatch();
    
    // Auto-correct pax based on seat
    if (this.value.trim()) {
        if (!isPaxRestrictedAirline(flightValue)) {
            autoCorrectPaxFromSeat(this, zoomPaxInput);
        } else {
            // For restricted airlines, always set pax to 1
            zoomPaxInput.value = '1';
        }
    }
});

zoomFlightInput.addEventListener('input', function() {
    const flightValue = this.value.trim();
    const seatValue = zoomSeatInput.value.trim();
    
    // Auto-select airline based on flight code
    if (this.value.length >= 2) {
        const iata = this.value.substring(0, 2).toUpperCase();
        if (airlines[iata]) {
            zoomAirlineSelect.value = iata;
        }
    }
    
    // Auto-correct seat if airline is restricted
    if (flightValue && seatValue && isPaxRestrictedAirline(flightValue)) {
        const correctedSeat = autoCorrectSeatForRestrictedAirline(flightValue, seatValue);
        if (correctedSeat !== seatValue) {
            zoomSeatInput.value = correctedSeat;
        }
    }
    
    checkZoomSeatPaxMatch();
});

refreshShiftBtn.addEventListener('click', refreshShiftData);

// Delay charge event listeners
delayChargeBtn.addEventListener('click', showDelayChargeModal);
closeModalBtn.addEventListener('click', () => {
    delayChargeModal.classList.remove('show');
});

calculateDelayBtn.addEventListener('click', handleCalculateDelay);
saveDelayBtn.addEventListener('click', saveDelayChargeEntry);

// Local storage event listeners
storageManagerBtn.addEventListener('click', showLocalStorageModal);
closeStorageModalBtn.addEventListener('click', () => {
    localStorageModal.classList.remove('show');
});

refreshStorageBtn.addEventListener('click', loadStorageData);
clearAllStorageBtn.addEventListener('click', clearAllLocalStorage);

closeJsonViewerBtn.addEventListener('click', () => {
    jsonViewerModal.classList.remove('show');
});

// Close modals when clicking outside
delayChargeModal.addEventListener('click', (e) => {
    if (e.target === delayChargeModal) {
        delayChargeModal.classList.remove('show');
    }
});

localStorageModal.addEventListener('click', (e) => {
    if (e.target === localStorageModal) {
        localStorageModal.classList.remove('show');
    }
});

jsonViewerModal.addEventListener('click', (e) => {
    if (e.target === jsonViewerModal) {
        jsonViewerModal.classList.remove('show');
    }
});

numericKeyboardModal.addEventListener('click', (e) => {
    if (e.target === numericKeyboardModal) {
        closeNumericKeyboard();
    }
});

zoomModal.addEventListener('click', (e) => {
    if (e.target === zoomModal) {
        closeZoomModal();
    }
});

fqtvZoomModal.addEventListener('click', (e) => {
    if (e.target === fqtvZoomModal) {
        closeFqtvZoomModal();
    }
});

// ----- Initialize System -----
document.addEventListener('DOMContentLoaded', async function() {
    console.log("ðŸš€ Initializing unified passenger approval system...");
    console.log("ðŸ“‹ System Configuration:");
    console.log("- Card System: cardsystem-21773");
    console.log("- QR System: qrcards-2378e");
    console.log("- Delay Charge System: Enabled");
    console.log("- Storage Manager: Enabled");
    console.log("- FIXED: Manual Entry Zoom - Click only (no tab)");
    console.log("- FIXED: FQTV Zoom - Click AND Tab navigation");
    console.log("- FIXED: Seat-Pax alerts only on actual field changes");
    console.log("- FIXED: FQTV Tier mapping: Shows correct P/G/S, Platinum/Gold/Silver, or Emerald/Sapphire/Ruby");
    console.log("- FIXED: Auto-correct seats for restricted airlines (FZ,SQ,EY,QR,BA,MH,DE,GF,EK,VS,MU,HK)");
    console.log("- FIXED: QR system saves with same tier logic");
    console.log("- OPTIMIZED: Reduced Firebase reads (30min cache, 15min refresh)");
    console.log("- FIXED: Seat-Pax tally system (1A=1 pax, 1AB=2 pax, 1A/2B=2 pax)");
    console.log("- FIXED: Restricted airlines = 1 pax only and single seat only");
    
    clearOldProcessedCodes();
    
    loadApprovedEntriesCache();
    
    // Initialize numeric keyboard
    initializeNumericKeyboard();
    
    // Set up auto-zoom fields (FIXED: Click only, no tab)
    setupAutoZoomFields();
    
    // Setup FQTV field (FIXED: Both click and tab)
    setupFqtvField();
    
    setTimeout(() => {
        initializeQRFirebase();
        loadQREntries();
    }, 1000);
    
    const loadedFromCache = loadCurrentShiftFromLocalStorage();
    
    if (!loadedFromCache) {
        console.log("ðŸ”„ No fresh cache, fetching shift data from server");
        showNoShiftMessage();
        
        setTimeout(() => {
            fetchCurrentOpenShift();
        }, 1000);
    } else {
        console.log("âœ… Shift loaded from cache");
    }
    
    codeInput.addEventListener('input', handleScannerInput);
    
    codeInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            clearTimeout(scannerTimer);
            if (isScannerActive) {
                processScannerInput();
            } else {
                processManualInput();
            }
        }
    });
    
    codeInput.addEventListener('blur', handleFieldExit);
    
    renderEntries();
    
    // OPTIMIZED: Reduced periodic shift checks from 5 to 15 minutes
    setInterval(() => {
        if (currentShiftStatus === 'open') {
            console.log("ðŸ”„ Periodic shift check (15 min interval)");
            fetchCurrentOpenShift();
        }
    }, 15 * 60 * 1000); // 15 minutes
    
    // OPTIMIZED: Reduced QR entry loading from 2 to 10 minutes
    setInterval(() => {
        loadQREntries();
    }, 10 * 60 * 1000); // 10 minutes
    
    // Background sync of approved entries
    setInterval(() => {
        if (window.passengerDb && backgroundSaveQueue.length === 0) {
            processBackgroundSaveQueue();
        }
    }, 30 * 1000);
    
    window.addEventListener('beforeunload', () => {
        console.log("ðŸ§¹ Cleaning up before unload");
    });
});

// ----- Test function for FQTV tier mapping -----
window.testFqtvTierMapping = function() {
    const testCases = [
        {
            fqtv: 'QR 123456/N1',
            flight: 'QR123',
            expected: 'QR 123456/P',
            description: 'QR N1 on QR flight â†’ P'
        },
        {
            fqtv: 'QR 123456/N2',
            flight: 'QR456',
            expected: 'QR 123456/G',
            description: 'QR N2 on QR flight â†’ G'
        },
        {
            fqtv: 'QR 123456/N3',
            flight: 'QR789',
            expected: 'QR 123456/S',
            description: 'QR N3 on QR flight â†’ S'
        },
        {
            fqtv: 'EK 123456/N1',
            flight: 'EK123',
            expected: 'EK 123456/Platinum',
            description: 'EK N1 on EK flight â†’ Platinum'
        },
        {
            fqtv: 'BA 123456/N2',
            flight: 'BA456',
            expected: 'BA 123456/Gold',
            description: 'BA N2 on BA flight â†’ Gold'
        },
        {
            fqtv: 'AA 123456/N3',
            flight: 'AA789',
            expected: 'AA 123456/Silver',
            description: 'AA N3 on AA flight â†’ Silver'
        },
        {
            fqtv: 'BA 123456/N1',
            flight: 'EK123',
            expected: 'BA 123456/Emerald',
            description: 'BA N1 on EK flight â†’ Emerald'
        },
        {
            fqtv: 'AA 123456/N2',
            flight: 'QR456',
            expected: 'AA 123456/G',
            description: 'AA N2 on QR flight â†’ G'
        },
        {
            fqtv: 'AA 123456/N2',
            flight: 'BA789',
            expected: 'AA 123456/Sapphire',
            description: 'AA N2 on BA flight â†’ Sapphire'
        },
        {
            fqtv: 'EK 123456/N3',
            flight: 'QR123',
            expected: 'EK 123456/S',
            description: 'EK N3 on QR flight â†’ S'
        },
        {
            fqtv: 'QR 123456/N0',
            flight: 'QR123',
            expected: '',
            description: 'QR N0 â†’ empty'
        },
        {
            fqtv: 'EK 123456',
            flight: 'EK123',
            expected: 'EK 123456',
            description: 'No tier â†’ keep as is'
        }
    ];
    
    console.log("=== Testing FQTV Tier Mapping ===");
    let allPassed = true;
    
    testCases.forEach((test, index) => {
        const result = formatFqtvWithTier(test.fqtv, test.flight);
        const passed = result === test.expected;
        
        if (!passed) {
            allPassed = false;
        }
        
        console.log(`${passed ? 'âœ…' : 'âŒ'} Test ${index + 1}: ${test.description}`);
        console.log(`   Input: "${test.fqtv}" on flight ${test.flight}`);
        console.log(`   Result: "${result}"`);
        console.log(`   Expected: "${test.expected}"`);
        console.log('');
    });
    
    if (allPassed) {
        console.log("ðŸŽ‰ All tests passed!");
        alert("All FQTV tier mapping tests passed! Check console for details.");
    } else {
        console.log("âš ï¸ Some tests failed");
        alert("Some FQTV tier mapping tests failed. Check console for details.");
    }
};

// ----- Debug Functions -----
window.debugSystemsInfo = function() {
    console.log("=== DEBUG SYSTEMS INFO ===");
    console.log("Card System Project:", window.passengerDb ? "cardsystem-21773" : "Not initialized");
    console.log("QR System Project:", qrFirebaseConfig ? qrFirebaseConfig.projectId : "Not configured");
    console.log("QR Firebase Initialized:", qrFirebaseInitialized);
    console.log("QR System Available:", qrSystemAvailable);
    console.log("QR Entries Count:", qrEntries.length);
    console.log("QR Processed Codes:", qrEntriesProcessed.length);
    
    console.log("\n=== LOCAL STORAGE INFO ===");
    console.log("Pending Entries:", JSON.parse(localStorage.getItem('codesData') || '[]').length);
    console.log("Approved Entries (Local):", JSON.parse(localStorage.getItem('approvedLocalData') || '[]').length);
    console.log("Approved Cache Entries:", Object.keys(approvedEntriesCache).length);
    
    console.log("\n=== SHIFT INFO ===");
    console.log("Current Shift Type:", currentShiftType);
    console.log("Current Shift Date:", currentShiftDate);
    console.log("Current Shift Status:", currentShiftStatus);
    
    alert(`System Information:\n\n` +
          `Card System: ${window.passengerDb ? 'âœ… Initialized (cardsystem-21773)' : 'âŒ Not initialized'}\n` +
          `QR System: ${qrFirebaseInitialized ? 'âœ… Initialized (' + qrFirebaseConfig.projectId + ')' : 'âŒ Not initialized'}\n` +
          `QR Available: ${qrSystemAvailable ? 'âœ…' : 'âŒ'}\n` +
          `QR Entries: ${qrEntries.length}\n` +
          `QR Processed: ${qrEntriesProcessed.length}\n\n` +
          `Pending Entries: ${JSON.parse(localStorage.getItem('codesData') || '[]').length}\n` +
          `Approved (Local): ${JSON.parse(localStorage.getItem('approvedLocalData') || '[]').length}\n\n` +
          `Shift: ${currentShiftType || 'None'}\n` +
          `Date: ${currentShiftDate || '-'}\n` +
          `Status: ${currentShiftStatus}`);
};

// ----- QR System Helper Functions -----
window.openQRReport = function() {
    window.open('qrReport.html', '_blank');
};

// ----- Test QR System Connection -----
window.testQRConnection = async function() {
    if (!qrFirebaseInitialized || !qrSystemAvailable) {
        alert("QR system not initialized");
        return;
    }
    
    try {
        showAlert("Testing QR system connection...", false, false, true);
        
        const testData = {
            test: true,
            timestamp: getMaldivesDateTimeISO(),
            message: "Connection test from unified system"
        };
        
        const docRef = await qrDb.collection('testConnections').add(testData);
        alert(`âœ… QR System Connection Successful!\n\nProject: ${qrFirebaseConfig.projectId}\nTest Document ID: ${docRef.id}\n\nDocument saved successfully.`);
        
        await docRef.delete();
        
    } catch (error) {
        alert(`âŒ QR System Connection Failed!\n\nError: ${error.message}\n\nProject: ${qrFirebaseConfig.projectId}\n\nCheck:\n1. Firebase Firestore Rules\n2. Internet Connection\n3. Project Configuration`);
        console.error("Connection test error:", error);
    }
};

// ----- Test the pax calculation function -----
window.testPaxCalculation = function() {
    const testCases = [
        { seat: '1A', expected: 1 },
        { seat: '12ABC', expected: 3 },
        { seat: '1A/3B', expected: 2 },
        { seat: '15DEF/GHI', expected: 6 },
        { seat: '1', expected: 1 },
        { seat: '', expected: 1 },
        { seat: '12A,13B,14C', expected: 3 },
        { seat: '12A 13B 14C', expected: 3 },
        { seat: '1A/2B/3C', expected: 3 },
        { seat: '12A;13B', expected: 2 },
    ];
    
    console.log("=== Testing Seat-Pax Calculation ===");
    testCases.forEach(test => {
        const result = calculatePaxFromSeatNumber(test.seat);
        const passed = result === test.expected;
        console.log(`${passed ? 'âœ…' : 'âŒ'} Seat: "${test.seat}" => ${result} pax (expected: ${test.expected})`);
    });
    
    console.log("\n=== Testing Seat-Pax Validation ===");
    const validationTests = [
        { seat: '1A', pax: 1, expected: true },
        { seat: '1A', pax: 2, expected: false },
        { seat: '12ABC', pax: 3, expected: true },
        { seat: '12ABC', pax: 1, expected: false },
        { seat: '1A/2B', pax: 2, expected: true },
        { seat: '1A/2B', pax: 1, expected: false },
        { seat: '12A,13B,14C', pax: 3, expected: true },
        { seat: '12A,13B,14C', pax: 2, expected: false },
    ];
    
    validationTests.forEach(test => {
        const validation = validateSeatPaxMatch(test.seat, test.pax);
        const passed = validation.isValid === test.expected;
        console.log(`${passed ? 'âœ…' : 'âŒ'} Seat: "${test.seat}", Pax: ${test.pax} => ${validation.isValid ? 'VALID' : 'INVALID'} (expected: ${test.expected ? 'VALID' : 'INVALID'})`);
    });
    
    alert("Seat-Pax calculation tests completed. Check console for results.");
};

// ----- Quick test function -----
window.testSeatPax = function() {
    const testData = [
        { flight: 'FZ123', seat: '12ABC', expectedPax: 1 },
        { flight: 'SQ456', seat: '1A/3B', expectedPax: 1 },
        { flight: 'AA123', seat: '12ABC', expectedPax: 3 },
        { flight: 'EK789', seat: '12ABC', expectedPax: 1 },
        { flight: 'QR012', seat: '15DEF/GHI', expectedPax: 1 },
        { flight: 'DL123', seat: '1A/2B', expectedPax: 2 },
        { flight: 'UA456', seat: '12A,13B', expectedPax: 2 },
    ];
    
    console.log("=== Quick Seat-Pax Test ===");
    testData.forEach(test => {
        const calculated = calculatePaxFromSeatNumber(test.seat);
        const restricted = isPaxRestrictedAirline(test.flight);
        const finalPax = restricted ? 1 : calculated;
        const passed = finalPax === test.expectedPax;
        
        console.log(`${passed ? 'âœ…' : 'âŒ'} Flight: ${test.flight}, Seat: ${test.seat}`);
        console.log(`   Calculated: ${calculated}, Restricted: ${restricted}, Final: ${finalPax}, Expected: ${test.expectedPax}`);
    });
    
    console.log("\n=== Manual Entry Test ===");
    // Focus on name input to trigger auto-zoom
    nameInput.focus();
};
</script>
</body>
</html>
