<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Code Parser & Passenger Approval</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
  :root {
    --gold: #D4AF37;
    --gold-light: #F5E8B8;
    --gold-dark: #B8860B;
    --gold-darker: #8B6914;
    --white: #FFFFFF;
    --gray-light: #F8F8F8;
    --gray: #E5E5E5;
    --gray-dark: #666666;
    --success: #4CAF50;
    --error: #f44336;
    --warning: #ff9800;
    --info: #2196F3;
    --shift-blue: #4b6cb7;
    --shift-blue-dark: #182848;
  }
  
  * {
    box-sizing: border-box;
  }
  
  body { 
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
    padding: 20px; 
    background: var(--white);
    margin: 0;
    color: #333;
    background-color: #f9f9f9;
  }
  
  .container {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    max-width: 1600px;
    margin: 0 auto;
  }
  
  .entry-section {
    flex: 1;
    min-width: 280px;
    max-width: 350px;
    background: var(--white);
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 6px 15px rgba(0,0,0,0.08);
    border: 1px solid var(--gold);
    position: relative;
    overflow: hidden;
  }
  
  .entry-section::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 4px;
    background: linear-gradient(90deg, var(--gold), var(--gold-dark));
  }
  
  .entries-section {
    flex: 4;
    min-width: 900px;
    background: var(--white);
    padding: 25px;
    border-radius: 10px;
    box-shadow: 0 6px 15px rgba(0,0,0,0.08);
    border: 1px solid var(--gold);
    overflow-x: auto;
    position: relative;
  }
  
  .entries-section::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 4px;
    background: linear-gradient(90deg, var(--gold), var(--gold-dark));
  }
  
  h2, h3 {
    margin-top: 0;
    color: var(--gold-darker);
    padding-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 10px;
    font-weight: 600;
  }
  
  h2 i, h3 i {
    color: var(--gold);
  }
  
  .form-group {
    margin-bottom: 15px;
  }
  
  label {
    display: block;
    margin-bottom: 6px;
    font-weight: 600;
    font-size: 14px;
    color: var(--gold-darker);
  }
  
  .input-with-icon {
    position: relative;
  }
  
  .input-with-icon i {
    position: absolute;
    left: 12px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--gold);
    z-index: 1;
  }
  
  input, select, textarea { 
    width: 100%; 
    padding: 10px 10px 10px 35px;
    border: 1px solid var(--gold); 
    border-radius: 6px; 
    font-size: 14px; 
    box-sizing: border-box;
    background: var(--white);
    transition: all 0.3s ease;
  }
  
  input:focus, select:focus, textarea:focus {
    outline: none;
    border-color: var(--gold-dark);
    box-shadow: 0 0 0 3px var(--gold-light);
  }
  
  textarea {
    resize: vertical;
    min-height: 60px;
    padding-left: 35px;
  }
  
  table { 
    width: 100%; 
    border-collapse: collapse; 
    margin-top: 10px;
    font-size: 13px;
    border: 1px solid var(--gold);
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
  }
  
  th, td { 
    border: 1px solid var(--gold); 
    padding: 10px; 
    text-align: left; 
    white-space: nowrap;
  }
  
  th {
    background-color: var(--gold-light);
    font-weight: bold;
    color: var(--gold-darker);
    position: sticky;
    top: 0;
  }
  
  tr:nth-child(even) {
    background-color: var(--gray-light);
  }
  
  tr:hover {
    background-color: rgba(212, 175, 55, 0.1);
  }
  
  button.action-btn { 
    width: auto; 
    margin: 0 2px; 
    padding: 8px 14px; 
    font-size: 12px; 
    cursor: pointer; 
    background: var(--gold);
    color: white;
    border: none;
    border-radius: 4px;
    transition: all 0.3s ease;
    display: inline-flex;
    align-items: center;
    gap: 5px;
    font-weight: 500;
  }
  
  button.action-btn:hover {
    background: var(--gold-dark);
    transform: translateY(-2px);
    box-shadow: 0 3px 8px rgba(0,0,0,0.15);
  }
  
  button.action-btn:disabled {
    opacity: 0.6;
    pointer-events: none;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
  }
  
  .button-group {
    display: flex;
    gap: 10px;
    margin-top: 20px;
  }
  
  .button-group button {
    flex: 1;
    padding: 12px;
    font-weight: 600;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
    border-radius: 6px;
    font-size: 14px;
  }
  
  #manualSaveBtn {
    background: var(--gold);
    color: white;
    box-shadow: 0 3px 8px rgba(212, 175, 55, 0.3);
  }
  
  #manualSaveBtn:hover {
    background: var(--gold-dark);
    box-shadow: 0 5px 12px rgba(212, 175, 55, 0.4);
  }
  
  .status-indicator {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 15px;
    padding: 10px;
    background: var(--gold-light);
    border-radius: 6px;
    border-left: 4px solid var(--gold);
  }
  
  .status-indicator i {
    color: var(--gold-dark);
  }
  
  @media (max-width: 1200px) {
    .container {
      flex-direction: column;
    }
    
    .entry-section, .entries-section {
      min-width: 100%;
      max-width: 100%;
    }
  }
  
  .gold-line {
    height: 2px;
    background: linear-gradient(90deg, transparent, var(--gold), transparent);
    margin: 15px 0;
  }
  
  .section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
  }
  
  .entries-count {
    background: var(--gold);
    color: white;
    padding: 6px 14px;
    border-radius: 20px;
    font-size: 13px;
    font-weight: bold;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
  }
  
  .user-shift-container {
    display: flex;
    gap: 20px;
    margin-bottom: 15px;
    justify-content: flex-start;
    align-items: center;
    flex-wrap: wrap;
  }
  
  .user-shift-field {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
  }
  
  .user-shift-field label {
    font-size: 14px;
    margin-bottom: 0;
    color: var(--gold-darker);
    font-weight: 600;
  }
  
  .user-shift-field span {
    background: var(--gold-light);
    padding: 8px 14px;
    border-radius: 6px;
    border: 1px solid var(--gold);
    min-width: 120px;
    display: inline-block;
    font-weight: 500;
    text-align: center;
  }
  
  .clear-notification {
    position: fixed;
    top: 20px;
    right: 20px;
    background: var(--success);
    color: white;
    padding: 12px 24px;
    border-radius: 6px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    display: flex;
    align-items: center;
    gap: 10px;
    z-index: 1000;
    opacity: 0;
    transform: translateY(-20px);
    transition: all 0.3s ease;
  }
  
  .clear-notification.show {
    opacity: 1;
    transform: translateY(0);
  }
  
  .shift-status {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 15px;
    padding: 10px;
    background: var(--gray-light);
    border-radius: 6px;
    border-left: 4px solid var(--gold);
  }
  
  .status-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: var(--success);
  }
  
  .status-dot.inactive {
    background: var(--error);
  }
  
  .disabled {
    opacity: 0.6;
    pointer-events: none;
  }
  
  .float-nav {
    position: fixed;
    bottom: 30px;
    right: 30px;
    display: flex;
    flex-direction: column;
    gap: 15px;
    z-index: 1000;
  }
  
  .float-btn {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: var(--gold);
    color: white;
    border: none;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
  }
  
  .float-btn:hover {
    background: var(--gold-dark);
    transform: translateY(-3px);
    box-shadow: 0 6px 20px rgba(0,0,0,0.3);
  }
  
  .float-btn::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255,255,255,0.1);
    opacity: 0;
    transition: opacity 0.3s ease;
  }
  
  .float-btn:hover::after {
    opacity: 1;
  }
  
  .float-tooltip {
    position: absolute;
    right: 70px;
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 14px;
    white-space: nowrap;
    opacity: 0;
    transform: translateX(10px);
    transition: all 0.3s ease;
    pointer-events: none;
  }
  
  .float-btn:hover .float-tooltip {
    opacity: 1;
    transform: translateX(0);
  }
  
  @media (max-width: 768px) {
    .float-nav {
      bottom: 20px;
      right: 20px;
    }
    
    .float-btn {
      width: 50px;
      height: 50px;
      font-size: 18px;
    }
    
    .float-tooltip {
      font-size: 12px;
      padding: 6px 10px;
    }
  }

  .scanner-indicator {
    display: none;
    align-items: center;
    gap: 8px;
    margin-top: 8px;
    font-size: 12px;
    color: var(--gold-dark);
  }
  
  .scanner-indicator.show {
    display: flex;
  }
  
  .scanner-dots {
    display: flex;
    gap: 3px;
  }
  
  .scanner-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--gold);
    animation: scanning 0.8s infinite ease-in-out;
  }
  
  .scanner-dot:nth-child(1) { animation-delay: -0.32s; }
  .scanner-dot:nth-child(2) { animation-delay: -0.16s; }
  
  @keyframes scanning {
    0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
    40% { transform: scale(1); opacity: 1; }
  }
  
  .alert-notification {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%) translateY(-20px);
    background: var(--success);
    color: white;
    padding: 12px 24px;
    border-radius: 6px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    display: flex;
    align-items: center;
    gap: 10px;
    z-index: 1000;
    opacity: 0;
    transition: all 0.3s ease;
  }
  
  .alert-notification.show {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
  
  .alert-notification.error {
    background: var(--error);
  }
  
  .alert-notification.warning {
    background: var(--warning);
  }
  
  .alert-notification.info {
    background: var(--info);
  }
  
  .spinner {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid rgba(255,255,255,0.3);
    border-radius: 50%;
    border-top-color: white;
    animation: spin 1s ease-in-out infinite;
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  
  .card-header {
    background: linear-gradient(135deg, var(--gold-light), var(--gold));
    padding: 15px 20px;
    margin: -20px -20px 15px -20px;
    border-radius: 10px 10px 0 0;
    color: var(--gold-darker);
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  
  .fqtv-required {
    background-color: rgba(255, 152, 0, 0.1) !important;
    border-left: 3px solid var(--warning) !important;
  }
  
  .fqtv-warning {
    color: var(--warning);
    font-weight: bold;
    font-style: italic;
  }
  
  .flight-closed {
    background-color: rgba(244, 67, 54, 0.1) !important;
    border-left: 3px solid var(--error) !important;
  }
  
  .flight-closed td {
    opacity: 0.8;
  }
  
  .flight-status-closed {
    color: var(--error);
    font-weight: bold;
    font-size: 0.9em;
    margin-left: 5px;
  }
  
  .flight-closed .action-btn:first-child {
    background: var(--gray) !important;
    color: var(--gray-dark) !important;
    cursor: not-allowed;
    opacity: 0.6;
  }
  
  .flight-closed .action-btn:first-child:hover {
    transform: none !important;
    box-shadow: none !important;
  }
  
  .entry-fields-container {
    margin-top: 10px;
  }
  
  .simple-field-group {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
  }
  
  .simple-field-group .form-group {
    flex: 1;
    margin-bottom: 0;
  }
  
  .entry-card-title {
    text-align: center;
    margin-bottom: 20px;
    color: var(--gold-darker);
    font-size: 18px;
    font-weight: 600;
  }
  
  .no-shift-message {
    text-align: center;
    padding: 10px;
    color: #666;
    font-size: 13px;
  }

  .shift-refresh-btn {
    background: var(--shift-blue);
    color: white;
    border: none;
    border-radius: 5px;
    padding: 8px 16px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
    transition: all 0.3s ease;
  }
  
  .shift-refresh-btn:hover {
    background: var(--shift-blue-dark);
    transform: translateY(-1px);
  }
  
  .shift-refresh-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
  }
  
  @media (max-width: 768px) {
    .user-shift-container {
      flex-direction: column;
      align-items: flex-start;
      gap: 10px;
    }
    
    .user-shift-field {
      width: 100%;
      justify-content: space-between;
    }
    
    .user-shift-field span {
      min-width: 150px;
      text-align: right;
    }
  }
</style>
</head>
<body>

<div class="clear-notification" id="clearNotification">
  <i class="fas fa-check-circle"></i>
  <span>Fields cleared for next entry</span>
</div>

<div class="alert-notification" id="alertNotification">
  <i class="fas fa-check-circle"></i>
  <span id="alertMessage">Operation completed successfully</span>
</div>

<div class="float-nav">
  <button id="refreshShiftBtn" class="float-btn shift-refresh-float">
    <i class="fas fa-sync-alt"></i>
    <span class="float-tooltip">Refresh Shift</span>
  </button>
  <a href="dash.html" class="float-btn">
    <i class="fas fa-home"></i>
    <span class="float-tooltip">Home Dashboard</span>
  </a>
  <a href="updateCard.html" class="float-btn">
    <i class="fas fa-chart-bar"></i>
    <span class="float-tooltip">Reports</span>
  </a>
</div>

<div class="container">
  <div class="entry-section" id="passengerEntryCard">
    <div class="entry-card-title">
      <i class="fas fa-user-plus"></i> Enter Passenger Details
    </div>
    
    <div class="form-group">
      <label for="codeInput"><i class="fas fa-barcode"></i> Scan Barcode</label>
      <div class="input-with-icon">
        <i class="fas fa-qrcode"></i>
        <input id="codeInput" placeholder="Scan or paste barcode" autocomplete="off">
      </div>
      <div class="scanner-indicator" id="scannerIndicator">
        <div class="scanner-dots">
          <div class="scanner-dot"></div>
          <div class="scanner-dot"></div>
          <div class="scanner-dot"></div>
        </div>
        <span>Processing barcode...</span>
      </div>
    </div>
    
    <div class="gold-line"></div>
    
    <div class="entry-fields-container">
      <div class="simple-field-group">
        <div class="form-group">
          <label for="nameInput"><i class="fas fa-user"></i> Name</label>
          <div class="input-with-icon">
            <i class="fas fa-signature"></i>
            <input id="nameInput" placeholder="Passenger name">
          </div>
        </div>
        
        <div class="form-group">
          <label for="flightInput"><i class="fas fa-plane"></i> Flight</label>
          <div class="input-with-icon">
            <i class="fas fa-plane-departure"></i>
            <input id="flightInput" placeholder="Flight number">
          </div>
        </div>
      </div>
      
      <div class="simple-field-group">
        <div class="form-group">
          <label for="pnrInput"><i class="fas fa-ticket-alt"></i> PNR</label>
          <div class="input-with-icon">
            <i class="fas fa-receipt"></i>
            <input id="pnrInput" placeholder="PNR code">
          </div>
        </div>
        
        <div class="form-group">
          <label for="seatInput"><i class="fas fa-chair"></i> Seat</label>
          <div class="input-with-icon">
            <i class="fas fa-couch"></i>
            <input id="seatInput" placeholder="Seat number">
          </div>
        </div>
      </div>
      
      <div class="simple-field-group">
        <div class="form-group">
          <label for="airlineSelect"><i class="fas fa-building"></i> Airline</label>
          <div class="input-with-icon">
            <i class="fas fa-warehouse"></i>
            <select id="airlineSelect"><option value="">Select Airline</option></select>
          </div>
        </div>
        
        <div class="form-group">
          <label for="classInput"><i class="fas fa-star"></i> Class</label>
          <div class="input-with-icon">
            <i class="fas fa-star-half-alt"></i>
            <input id="classInput" placeholder="Class" readonly>
          </div>
        </div>
      </div>
      
      <div class="simple-field-group">
        <div class="form-group">
          <label for="fqtvInput"><i class="fas fa-id-card"></i> FQTV</label>
          <div class="input-with-icon">
            <i class="fas fa-address-card"></i>
            <input id="fqtvInput" placeholder="FQTV" readonly>
          </div>
        </div>
        
        <div class="form-group">
          <label for="numPaxInput"><i class="fas fa-users"></i> Pax</label>
          <div class="input-with-icon">
            <i class="fas fa-user-friends"></i>
            <input id="numPaxInput" placeholder="No of Pax" type="number" value="1" min="1">
          </div>
        </div>
      </div>
      
      <div class="form-group">
        <label for="serialInput"><i class="fas fa-hashtag"></i> Serial No</label>
        <div class="input-with-icon">
          <i class="fas fa-list-ol"></i>
          <input id="serialInput" placeholder="Serial number">
        </div>
      </div>
      
      <div class="form-group">
        <label for="remarksInput"><i class="fas fa-sticky-note"></i> Remarks</label>
        <div class="input-with-icon">
          <i class="fas fa-comment-alt"></i>
          <textarea id="remarksInput" placeholder="Additional remarks"></textarea>
        </div>
      </div>
    </div>
    
    <div class="button-group">
      <button id="manualSaveBtn"><i class="fas fa-save"></i> Save Entry</button>
    </div>
  </div>
  
  <div class="entries-section">
    <div class="section-header">
      <h3><i class="fas fa-list-alt"></i> Saved Entries</h3>
      <div class="entries-count" id="entriesCount">0 entries</div>
    </div>
    
    <div class="user-shift-container">
      <div class="user-shift-field">
        <label>User:</label>
        <span id="userDisplay">Loading...</span>
      </div>
      <div class="user-shift-field">
        <label>Current Shift:</label>
        <span id="shiftDisplay">Loading...</span>
      </div>
      <div class="user-shift-field">
        <label>Shift Date:</label>
        <span id="dateDisplay">-</span>
      </div>
    </div>
    
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Flight</th>
          <th>Seat</th>
          <th>Class</th>
          <th>FQTV</th>
          <th>Pax</th>
          <th>Serial</th>
          <th>Remarks</th>
          <th>PNR</th>
          <th>Date</th>
          <th>Shift</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody id="entriesList"></tbody>
    </table>
  </div>
</div>

<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
<script src="./firebackup.js"></script>
<script src="./fireC1.js"></script>
<!-- Shift System Firebase Configuration -->
<script src="./fireshift.js"></script>
<script>
// ----- Airlines dropdown -----
const airlines = {
  'EK':'Emirates','FZ':'Flydubai','BA':'British Airways','EY':'Etihad',
  'MH':'Malaysia Airlines','AI':'Air India','AZ':'Alitalia','VS':'Virgin Atlantic',
  'PG':'Bangkok Airways','GF':'Gulf Air','Q2':'Malindivian','UL':'Srilankan Airlines',
  'AK':'Air Asia','SQ':'Singapore Airlines','6E':'Indigo','OS':'Austrian Airlines',
  '8D':'Fits Air','SU':'Aeroflot','OD':'Batik Air','TK':'Turkish Airline',
  'G9':'Air Arabia','SV':'Saudia','MU':'China Eastern Airlines','BS':'US-Bangla Airlines',
  '3U':'Sichuan Airlines','A1': 'Avia Maldives', 'DR': 'DER Turistic Service AG', 'HP':'Hotel Plan', 'HU':'Humming Bird',
  'KU':'Kouni UK', 'NT' : 'Nanto Tours','MT':'Maldives Travel Factory', 'WI':'Wako International', 'KC':'Air Astana','HIS':'Japan HIS Tours',
  'JD':'Capital Airlines', 'J2':'Azerbaijan Airlines', 'VO':'Voyages Maldives', 'WK':'Edelweiss','DE':'Condor','NO':'Neos','4Y':'Discover Airlines',
  // Add more airlines for FQTV detection
  'JL':'Japan Airlines', 'QF':'Qantas Airways', 'CX':'Cathay Pacific', 'AA':'American Airlines',
  'LA':'LATAM Airlines', 'AY':'Finnair', 'IB':'Iberia', 'QR':'Qatar Airways'
};

// ----- FQTV Tier Level Mappings -----
const fqtvTierMappings = {
  'same': {
    'n3': 'Platinum',
    'n2': 'Gold',
    'n1': 'Silver'
  },
  'different': {
    'n3': 'Emerald',
    'n2': 'Sapphire',
    'n1': 'Ruby'
  }
};

// ----- Initialize Airline Dropdown -----
const airlineSelect = document.getElementById('airlineSelect');
for(let iata in airlines){
  const opt = document.createElement('option');
  opt.value = iata;
  opt.textContent = airlines[iata];
  airlineSelect.appendChild(opt);
}

// ----- Elements -----
const codeInput = document.getElementById('codeInput');
const nameInput = document.getElementById('nameInput');
const pnrInput = document.getElementById('pnrInput');
const flightInput = document.getElementById('flightInput');
const seatInput = document.getElementById('seatInput');
const classInput = document.getElementById('classInput');
const fqtvInput = document.getElementById('fqtvInput');
const serialInput = document.getElementById('serialInput');
const remarksInput = document.getElementById('remarksInput');
const numPaxInput = document.getElementById('numPaxInput');
const userDisplay = document.getElementById('userDisplay');
const shiftDisplay = document.getElementById('shiftDisplay');
const dateDisplay = document.getElementById('dateDisplay');
const entriesList = document.getElementById('entriesList');
const manualSaveBtn = document.getElementById('manualSaveBtn');
const entriesCount = document.getElementById('entriesCount');
const clearNotification = document.getElementById('clearNotification');
const alertNotification = document.getElementById('alertNotification');
const alertMessage = document.getElementById('alertMessage');
const passengerEntryCard = document.getElementById('passengerEntryCard');
const scannerIndicator = document.getElementById('scannerIndicator');
const refreshShiftBtn = document.getElementById('refreshShiftBtn');

// ----- Global Variables -----
let isApproving = false;
let currentShiftType = null;
let currentShiftDate = null; // Will be in "YYYY-MM-DD" format
let renderTimeout = null;
let isRendering = false;
let lastRenderData = '';
let currentShiftStatus = 'not_started';
let shiftDb = null;
let backgroundSaveQueue = [];
let isBackgroundSaving = false;

// ----- Optimized Duplicate Tracking -----
let approvedEntriesCache = {};
let flightStatusCache = {};

// ----- DATE FORMAT FUNCTIONS -----

// Format date to YYYY-MM-DD
function formatDateToYYYYMMDD(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

// Parse date from various formats to YYYY-MM-DD
function parseDateToYYYYMMDD(dateString) {
  if (!dateString) return formatDateToYYYYMMDD(new Date());
  
  try {
    // Try to parse the date string
    let date = new Date(dateString);
    
    // If date is invalid, try different formats
    if (isNaN(date.getTime())) {
      // Try to parse from "Month DD, YYYY" format (e.g., "Dec 19, 2025")
      const monthNames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
      const dateLower = dateString.toLowerCase();
      
      for (let i = 0; i < monthNames.length; i++) {
        if (dateLower.includes(monthNames[i])) {
          // Try to extract date parts
          const match = dateString.match(/([A-Za-z]{3})\s+(\d{1,2}),?\s+(\d{4})/);
          if (match) {
            const [, monthStr, day, year] = match;
            const monthIndex = monthNames.indexOf(monthStr.toLowerCase());
            if (monthIndex !== -1) {
              date = new Date(year, monthIndex, parseInt(day));
              break;
            }
          }
        }
      }
      
      // If still invalid, try YYYY_MM_DD format
      if (isNaN(date.getTime())) {
        const match = dateString.match(/(\d{4})[_\-\/](\d{2})[_\-\/](\d{2})/);
        if (match) {
          const [, year, month, day] = match;
          date = new Date(`${year}-${month}-${day}`);
        } else {
          // Default to today
          date = new Date();
        }
      }
    }
    
    return formatDateToYYYYMMDD(date);
  } catch (error) {
    console.error('Error parsing date:', error);
    return formatDateToYYYYMMDD(new Date());
  }
}

// Format date for document ID: YYYY_MM_DD (for shift documents)
function formatDateForDocumentId(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}_${month}_${day}`;
}

// Format date for display: Month Day, Year
function formatDateForDisplay(dateString) {
  if (!dateString) return '-';
  try {
    // First try to parse as YYYY-MM-DD
    if (dateString.match(/^\d{4}-\d{2}-\d{2}$/)) {
      const [year, month, day] = dateString.split('-').map(Number);
      const date = new Date(year, month - 1, day);
      if (!isNaN(date.getTime())) {
        return date.toLocaleDateString('en-US', {
          month: 'short',
          day: 'numeric',
          year: 'numeric'
        });
      }
    }
    
    // Try parsing as a general date string
    const date = new Date(dateString);
    if (!isNaN(date.getTime())) {
      return date.toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric'
      });
    }
    
    return dateString;
  } catch (error) {
    console.error('Error formatting date for display:', error);
    return dateString;
  }
}

// Get current date in YYYY-MM-DD format
function getCurrentDate(){ 
  return formatDateToYYYYMMDD(new Date());
}

// Get current time in HH:MM format
function getCurrentTime(){ 
  return new Date().toTimeString().split(' ')[0].slice(0,5); 
}

// ----- Convert existing data to YYYY-MM-DD format -----
function convertExistingDataToYYYYMMDD() {
  try {
    // Convert codesData
    let codesData = JSON.parse(localStorage.getItem('codesData') || '[]');
    let updated = false;
    
    codesData = codesData.map(entry => {
      if (entry.date && entry.date.includes(',')) {
        entry.date = parseDateToYYYYMMDD(entry.date);
        updated = true;
      }
      return entry;
    });
    
    if (updated) {
      localStorage.setItem('codesData', JSON.stringify(codesData));
      console.log("Converted codesData to YYYY-MM-DD format");
    }
    
    // Convert approvedLocalData
    let approvedLocalData = JSON.parse(localStorage.getItem('approvedLocalData') || '[]');
    updated = false;
    
    approvedLocalData = approvedLocalData.map(entry => {
      if (entry.date && entry.date.includes(',')) {
        entry.date = parseDateToYYYYMMDD(entry.date);
        updated = true;
      }
      return entry;
    });
    
    if (updated) {
      localStorage.setItem('approvedLocalData', JSON.stringify(approvedLocalData));
      console.log("Converted approvedLocalData to YYYY-MM-DD format");
    }
    
    // Convert approvedEntriesCache
    let approvedEntriesCache = JSON.parse(localStorage.getItem('approvedEntriesCache') || '{}');
    updated = false;
    
    for (const key in approvedEntriesCache) {
      const entry = approvedEntriesCache[key];
      if (entry.date && entry.date.includes(',')) {
        entry.date = parseDateToYYYYMMDD(entry.date);
        updated = true;
      }
    }
    
    if (updated) {
      localStorage.setItem('approvedEntriesCache', JSON.stringify(approvedEntriesCache));
      console.log("Converted approvedEntriesCache to YYYY-MM-DD format");
    }
    
    // Convert currentShiftInfo
    const currentShiftInfo = localStorage.getItem('currentShiftInfo');
    if (currentShiftInfo) {
      const shiftInfo = JSON.parse(currentShiftInfo);
      if (shiftInfo.shiftDate && shiftInfo.shiftDate.includes(',')) {
        shiftInfo.shiftDate = parseDateToYYYYMMDD(shiftInfo.shiftDate);
        localStorage.setItem('currentShiftInfo', JSON.stringify(shiftInfo));
        console.log("Converted currentShiftInfo to YYYY-MM-DD format");
      }
    }
    
  } catch (error) {
    console.error('Error converting data to YYYY-MM-DD:', error);
  }
}

// ----- SHIFT MANAGEMENT FUNCTIONS -----

// Initialize Shift Firebase from fireshift.js
function initializeShiftFirebase() {
  try {
    if (typeof shiftFirebaseConfig === 'undefined') {
      console.error("shiftFirebaseConfig is not defined in fireshift.js");
      showAlert("Shift system configuration not found", true);
      return false;
    }
    
    if (!firebase.apps.some(app => app.name === 'shiftSystem')) {
      const shiftApp = firebase.initializeApp(shiftFirebaseConfig, 'shiftSystem');
      shiftDb = firebase.firestore(shiftApp);
      console.log("Shift Firebase initialized successfully from fireshift.js");
    } else {
      shiftDb = firebase.app('shiftSystem').firestore();
    }
    
    return true;
  } catch (error) {
    console.error("Error initializing shift Firebase:", error);
    showAlert("Shift system connection error", true);
    return false;
  }
}

// Check if a shift document has an open shift
function checkForOpenShift(shiftData) {
  let result = {
    success: false,
    isActive: false,
    shiftName: "No Shift Open",
    shiftType: "",
    openTime: "",
    details: {}
  };
  
  if (!shiftData) {
    return result;
  }
  
  // Check morning shift
  if (shiftData.morning && shiftData.morning.status === 'open') {
    result.success = true;
    result.isActive = true;
    result.shiftName = "Morning Shift";
    result.shiftType = "morning";
    result.openTime = shiftData.morning.open || "";
    result.details = shiftData.morning;
    return result;
  }
  
  // Check evening shift
  if (shiftData.evening && shiftData.evening.status === 'open') {
    result.success = true;
    result.isActive = true;
    result.shiftName = "Evening Shift";
    result.shiftType = "evening";
    result.openTime = shiftData.evening.open || "";
    result.details = shiftData.evening;
    return result;
  }
  
  // Check if both shifts are "not_available"
  if (shiftData.morning && shiftData.morning.status === "not_available" && 
      shiftData.evening && shiftData.evening.status === "not_available") {
    result.success = true;
    result.shiftName = "Shifts Not Started Today";
    return result;
  }
  
  // Check if both shifts are closed
  if ((!shiftData.morning || shiftData.morning.status === "closed") && 
      (!shiftData.evening || shiftData.evening.status === "closed")) {
    result.success = true;
    result.shiftName = "All Shifts Closed";
    return result;
  }
  
  // Default case
  result.success = true;
  return result;
}

// Search previous dates for open shift
async function findOpenShiftInPreviousDates(startDate) {
  try {
    // Search up to 7 previous days
    for (let i = 1; i <= 7; i++) {
      // Go back i days
      const previousDate = new Date(startDate);
      previousDate.setDate(startDate.getDate() - i);
      
      // Format for document ID: YYYY_MM_DD
      const previousDateForDocId = formatDateForDocumentId(previousDate);
      const previousDocId = `shift_${previousDateForDocId}`;
      
      // Format for YYYY-MM-DD
      const previousDateForYYYYMMDD = formatDateToYYYYMMDD(previousDate);
      
      console.log(`üìÖ Checking previous date ${i} day(s) ago: ${previousDateForDocId}`);
      
      try {
        const previousDoc = await shiftDb.collection("shifts").doc(previousDocId).get();
        
        if (previousDoc.exists) {
          const shiftData = previousDoc.data();
          console.log(`‚úÖ Found document for ${previousDocId}`);
          
          // Check if this document has an open shift
          const shiftCheck = checkForOpenShift(shiftData);
          
          if (shiftCheck.isActive) {
            console.log(`üéâ Found open shift in previous date: ${previousDateForYYYYMMDD}`);
            return {
              success: true,
              shiftData: shiftData,
              foundDate: previousDateForYYYYMMDD,
              foundDateForDocId: previousDateForDocId,
              shiftCheck: shiftCheck
            };
          } else {
            console.log(`‚û°Ô∏è No open shift in ${previousDateForYYYYMMDD}, continuing search...`);
          }
        } else {
          console.log(`‚û°Ô∏è No document for ${previousDateForYYYYMMDD}, continuing...`);
        }
      } catch (error) {
        console.error(`‚ùå Error checking ${previousDateForYYYYMMDD}:`, error);
      }
    }
    
    console.log("üîç No open shift found in any of the previous 7 days");
    return {
      success: false,
      message: "No open shift found in previous dates"
    };
    
  } catch (error) {
    console.error("‚ùå Error searching previous dates:", error);
    return {
      success: false,
      message: "Error: " + error.message
    };
  }
}

// Fetch current open shift with previous date search
async function fetchCurrentOpenShift() {
  try {
    refreshShiftBtn.innerHTML = '<div class="spinner"></div>';
    refreshShiftBtn.disabled = true;
    
    if (!shiftDb) {
      if (!initializeShiftFirebase()) {
        showNoShiftMessage();
        refreshShiftBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
        refreshShiftBtn.disabled = false;
        return;
      }
    }
    
    // Get today's date
    const today = new Date();
    
    // Format for document ID: YYYY_MM_DD
    const todayDateForDocId = formatDateForDocumentId(today);
    
    // Format for YYYY-MM-DD
    const todayDateForYYYYMMDD = formatDateToYYYYMMDD(today);
    
    console.log("üìÖ Today's date for document ID:", todayDateForDocId);
    console.log("üìÖ Today's date for YYYY-MM-DD:", todayDateForYYYYMMDD);
    
    // Use document ID format: shift_YYYY_MM_DD
    const todayDocId = `shift_${todayDateForDocId}`;
    console.log("üîç Looking for today's shift document:", todayDocId);
    
    // Get today's shift document
    const todayShiftDoc = await shiftDb.collection("shifts").doc(todayDocId).get();
    
    let shiftData = null;
    let foundDate = todayDateForYYYYMMDD;
    let foundDateForDocId = todayDateForDocId;
    let shiftCheck = null;
    
    // Check if today's shift exists
    if (todayShiftDoc.exists) {
      shiftData = todayShiftDoc.data();
      const documentDate = shiftData.date ? parseDateToYYYYMMDD(shiftData.date) : todayDateForYYYYMMDD;
      
      console.log("‚úÖ Today's shift data retrieved:", shiftData);
      
      // Check if today has any open shift
      shiftCheck = checkForOpenShift(shiftData);
      
      if (shiftCheck.isActive) {
        console.log("‚úì Found open shift in today's document");
        foundDate = documentDate;
        foundDateForDocId = todayDateForDocId;
      } else {
        console.log("‚ö†Ô∏è No open shift found in today's document. Searching previous dates...");
        
        // Search for open shift in previous dates
        const previousOpenShift = await findOpenShiftInPreviousDates(today);
        
        if (previousOpenShift.success) {
          console.log(`‚úì Found open shift in previous date: ${previousOpenShift.foundDate}`);
          shiftData = previousOpenShift.shiftData;
          foundDate = previousOpenShift.foundDate;
          foundDateForDocId = previousOpenShift.foundDateForDocId;
          shiftCheck = previousOpenShift.shiftCheck;
        } else {
          console.log("‚ö†Ô∏è No open shift found in any date, using today's data");
          // Keep today's data even if no shift is open
        }
      }
    } else {
      console.log("‚ùå No shift document found for today:", todayDocId);
      
      // Search for open shift in previous dates
      const previousOpenShift = await findOpenShiftInPreviousDates(today);
      
      if (previousOpenShift.success) {
        console.log(`‚úì Found open shift in previous date: ${previousOpenShift.foundDate}`);
        shiftData = previousOpenShift.shiftData;
        foundDate = previousOpenShift.foundDate;
        foundDateForDocId = previousOpenShift.foundDateForDocId;
        shiftCheck = previousOpenShift.shiftCheck;
      } else {
        console.log("‚ö†Ô∏è No shift data found at all");
        showNoShiftMessage();
        showAlert("No shift data found for today or previous dates", true);
        refreshShiftBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
        refreshShiftBtn.disabled = false;
        return;
      }
    }
    
    if (!shiftCheck || !shiftCheck.isActive) {
      console.log("‚ö†Ô∏è No active shift found in any date");
      showNoShiftMessage();
      showAlert("No active shift found. Please open a shift in Shift Management.", true);
      refreshShiftBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
      refreshShiftBtn.disabled = false;
      return;
    }
    
    console.log("üìä Final shift analysis:", shiftCheck);
    
    // Update global variables with YYYY-MM-DD format
    currentShiftType = shiftCheck.shiftType;
    currentShiftDate = foundDate; // This is now in YYYY-MM-DD format
    currentShiftStatus = 'open';
    
    // Format date for display with indicator if from previous day
    const displayDate = formatDateForDisplay(foundDate);
    
    let dateIndicator = "";
    const isFromPreviousDay = foundDate !== todayDateForYYYYMMDD;
    
    if (isFromPreviousDay) {
      const foundDateObj = new Date(foundDate);
      const todayObj = new Date(todayDateForYYYYMMDD);
      const daysDiff = Math.floor((todayObj - foundDateObj) / (1000 * 60 * 60 * 24));
      
      if (daysDiff === 1) {
        dateIndicator = " (Yesterday)";
      } else {
        dateIndicator = ` (${daysDiff} days ago)`;
      }
    }
    
    // Update UI
    shiftDisplay.textContent = shiftCheck.shiftName;
    dateDisplay.textContent = displayDate + dateIndicator;
    passengerEntryCard.classList.remove("disabled");
    
    // Save to localStorage
    saveCurrentShiftToLocalStorage(shiftData, shiftCheck.shiftName, 'open', foundDate, isFromPreviousDay);
    
    updateExistingEntriesDate();
    showAlert(`${shiftCheck.shiftName} is OPEN`, false);
    
  } catch (error) {
    console.error("‚ùå Error fetching shift data:", error);
    showNoShiftMessage();
    showAlert("Error loading shift information", true);
  } finally {
    refreshShiftBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
    refreshShiftBtn.disabled = false;
  }
}

// Save Current Shift to Local Storage
function saveCurrentShiftToLocalStorage(shiftData, shiftName, shiftStatus, foundDate, isFromPreviousDay = false) {
  const shiftInfo = {
    shiftName: shiftName,
    shiftType: currentShiftType,
    shiftDate: foundDate, // YYYY-MM-DD format
    shiftStatus: shiftStatus,
    isFromPreviousDay: isFromPreviousDay,
    morningOpen: shiftData.morning ? shiftData.morning.open : null,
    morningClose: shiftData.morning ? shiftData.morning.close : null,
    eveningOpen: shiftData.evening ? shiftData.evening.open : null,
    eveningClose: shiftData.evening ? shiftData.evening.close : null,
    lastUpdated: new Date().toISOString(),
    fetchedAt: new Date().toLocaleTimeString()
  };
  
  localStorage.setItem('currentShiftInfo', JSON.stringify(shiftInfo));
  console.log("Current shift saved to localStorage:", shiftInfo);
}

// Load Current Shift from Local Storage
function loadCurrentShiftFromLocalStorage() {
  try {
    const savedShift = localStorage.getItem('currentShiftInfo');
    if (savedShift) {
      const shiftInfo = JSON.parse(savedShift);
      
      // Check if shift is still fresh (less than 5 minutes old)
      const lastUpdated = new Date(shiftInfo.lastUpdated);
      const now = new Date();
      const minutesDiff = (now - lastUpdated) / (1000 * 60);
      
      if (minutesDiff < 5 && shiftInfo.shiftStatus === 'open') {
        currentShiftType = shiftInfo.shiftType;
        currentShiftDate = shiftInfo.shiftDate; // Already in YYYY-MM-DD format
        currentShiftStatus = shiftInfo.shiftStatus;
        
        // Format display date with indicator if from previous day
        let displayDate = formatDateForDisplay(shiftInfo.shiftDate);
        if (shiftInfo.isFromPreviousDay) {
          const shiftDateObj = new Date(shiftInfo.shiftDate);
          const todayObj = new Date();
          const daysDiff = Math.floor((todayObj - shiftDateObj) / (1000 * 60 * 60 * 24));
          
          if (daysDiff === 1) {
            displayDate += " (Yesterday)";
          } else {
            displayDate += ` (${daysDiff} days ago)`;
          }
        }
        
        shiftDisplay.textContent = shiftInfo.shiftName;
        dateDisplay.textContent = displayDate;
        passengerEntryCard.classList.remove("disabled");
        
        console.log("Loaded OPEN shift from localStorage:", shiftInfo);
        return true;
      } else {
        localStorage.removeItem('currentShiftInfo');
        console.log("Shift data expired or not open, removed from localStorage");
      }
    }
  } catch (error) {
    console.error("Error loading shift from localStorage:", error);
    localStorage.removeItem('currentShiftInfo');
  }
  return false;
}

function showNoShiftMessage() {
  shiftDisplay.textContent = "No Shift";
  dateDisplay.textContent = "-";
  passengerEntryCard.classList.add("disabled");
  currentShiftType = null;
  currentShiftDate = null;
  currentShiftStatus = 'not_started';
}

// ----- Alert System -----
function showAlert(message, isError = false, isWarning = false, isInfo = false) {
  alertMessage.textContent = message;
  alertNotification.className = 'alert-notification';
  
  if (isError) {
    alertNotification.classList.add('error');
    alertNotification.querySelector('i').className = 'fas fa-exclamation-circle';
  } else if (isWarning) {
    alertNotification.classList.add('warning');
    alertNotification.querySelector('i').className = 'fas fa-exclamation-triangle';
  } else if (isInfo) {
    alertNotification.classList.add('info');
    alertNotification.querySelector('i').className = 'fas fa-info-circle';
  } else {
    alertNotification.querySelector('i').className = 'fas fa-check-circle';
  }
  
  alertNotification.classList.add('show');
  
  setTimeout(() => {
    alertNotification.classList.remove('show');
  }, 3000);
}

// ----- Process FQTV Tier Level -----
function processFqtvTier(fqtvNumber, flightCode) {
  if (!fqtvNumber || fqtvNumber.trim() === '') return '';
  
  const fqtvUpper = fqtvNumber.toUpperCase();
  
  let tierCode = '';
  if (fqtvUpper.includes(' N3') || fqtvUpper.endsWith('N3') || fqtvUpper.includes('/N3')) {
    tierCode = 'n3';
  } else if (fqtvUpper.includes(' N2') || fqtvUpper.endsWith('N2') || fqtvUpper.includes('/N2')) {
    tierCode = 'n2';
  } else if (fqtvUpper.includes(' N1') || fqtvUpper.endsWith('N1') || fqtvUpper.includes('/N1')) {
    tierCode = 'n1';
  }
  
  if (!tierCode) {
    const tierMatch = fqtvUpper.match(/([Nn][123])$/);
    if (tierMatch) {
      tierCode = tierMatch[1].toLowerCase();
    }
  }
  
  if (!tierCode) return '';
  
  let fqtvAirlineCode = '';
  const fqtvMatch = fqtvUpper.match(/^([A-Z0-9]{2})[- ]/);
  if (fqtvMatch) {
    fqtvAirlineCode = fqtvMatch[1];
  } else {
    fqtvAirlineCode = fqtvUpper.substring(0, 2);
  }
  
  const flightAirlineCode = flightCode.slice(0, 2).toUpperCase();
  
  let tierMapping;
  if (fqtvAirlineCode && flightAirlineCode && 
      fqtvAirlineCode.toUpperCase() === flightAirlineCode.toUpperCase()) {
    // Same airline
    tierMapping = fqtvTierMappings.same;
  } else {
    // Different airline
    tierMapping = fqtvTierMappings.different;
  }
  
  return tierMapping[tierCode] || '';
}

// ----- User Authentication -----
const userData = JSON.parse(localStorage.getItem("loggedInUser"));

if (userData) {
    userDisplay.textContent = userData.name || userData.username;
} else {
    window.location.href = "login.html";
}

// ----- Background Save Queue Management -----
function addToBackgroundSaveQueue(approvedEntry, docName, localId) {
  backgroundSaveQueue.push({ approvedEntry, docName, localId });
  
  // Start background saving if not already running
  if (!isBackgroundSaving) {
    processBackgroundSaveQueue();
  }
}

async function processBackgroundSaveQueue() {
  if (isBackgroundSaving || backgroundSaveQueue.length === 0) return;
  
  isBackgroundSaving = true;
  
  while (backgroundSaveQueue.length > 0) {
    const item = backgroundSaveQueue[0];
    
    try {
      // Save to Firebase (fireC1.js) - ONLY ON APPROVAL
      await window.passengerDb.collection('passengers').doc(item.docName).set(item.approvedEntry);
      console.log(`‚úÖ Firebase save completed: ${item.docName}`);
      
      // Mark as synced in localStorage
      markAsSyncedInLocalStorage(item.localId);
      
      // Remove successfully saved item from queue
      backgroundSaveQueue.shift();
      
      // Small delay to prevent overwhelming Firebase
      await new Promise(resolve => setTimeout(resolve, 50));
      
    } catch (error) {
      console.error('‚ùå Firebase save failed:', error);
      
      // Retry logic: Move failed item to end of queue
      const failedItem = backgroundSaveQueue.shift();
      backgroundSaveQueue.push(failedItem);
      
      // Wait before retrying
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
  
  isBackgroundSaving = false;
}

// ----- Mark as synced in localStorage -----
function markAsSyncedInLocalStorage(localId) {
  try {
    let approvedLocalData = JSON.parse(localStorage.getItem('approvedLocalData') || '[]');
    
    approvedLocalData = approvedLocalData.map(item => {
      if (item.localId === localId) {
        return {
          ...item,
          synced: true,
          syncedAt: new Date().toISOString()
        };
      }
      return item;
    });
    
    // Remove synced items older than 7 days
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
    const sevenDaysAgoStr = formatDateToYYYYMMDD(sevenDaysAgo);
    
    approvedLocalData = approvedLocalData.filter(item => {
      if (item.synced) {
        const syncedDate = item.syncedAt || item.approvedAt;
        return syncedDate >= sevenDaysAgoStr;
      }
      return true; // Keep unsynced items
    });
    
    localStorage.setItem('approvedLocalData', JSON.stringify(approvedLocalData));
    console.log(`Marked ${localId} as synced`);
    
  } catch (error) {
    console.error('Error marking as synced:', error);
  }
}

// ----- Load Approved Entries Cache -----
function loadApprovedEntriesCache() {
  try {
    const cacheData = localStorage.getItem('approvedEntriesCache');
    if (cacheData) {
      approvedEntriesCache = JSON.parse(cacheData);
      
      const today = getCurrentDate();
      const sevenDaysAgo = new Date();
      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
      const sevenDaysAgoStr = formatDateToYYYYMMDD(sevenDaysAgo);
      
      for (const key in approvedEntriesCache) {
        if (approvedEntriesCache[key].date < sevenDaysAgoStr) {
          delete approvedEntriesCache[key];
        }
      }
      
      console.log(`Loaded ${Object.keys(approvedEntriesCache).length} approved entries from cache`);
    }
  } catch (error) {
    console.error('Error loading approved entries cache:', error);
    approvedEntriesCache = {};
  }
}

// ----- Save Approved Entry to Cache -----
function saveToApprovedCache(flight, seat, date, name = null, docId = null) {
  const flightUpper = flight.toUpperCase();
  const nameUpper = name ? name.toUpperCase() : '';
  const seatUpper = seat ? seat.toUpperCase() : '';
  const timestamp = Date.now();
  
  if (flightUpper.startsWith('SQ')) {
    if (nameUpper) {
      const uniqueKey = `${date}_SQ_${nameUpper}_${timestamp}`;
      approvedEntriesCache[uniqueKey] = {
        date: date,
        flight: flightUpper,
        name: nameUpper,
        seat: seatUpper || '',
        cachedAt: new Date().toISOString(),
        docId: docId,
        timestamp: timestamp
      };
    }
  } else {
    const seatKey = `${date}_${flightUpper}_${seatUpper}`;
    approvedEntriesCache[seatKey] = {
      date: date,
      flight: flightUpper,
      seat: seatUpper,
      cachedAt: new Date().toISOString(),
      docId: docId
    };
    
    if (nameUpper) {
      const exactKey = `${date}_${flightUpper}_${seatUpper}_${nameUpper}`;
      approvedEntriesCache[exactKey] = {
        date: date,
        flight: flightUpper,
        seat: seatUpper,
        name: nameUpper,
        cachedAt: new Date().toISOString(),
        docId: docId
      };
    }
  }
  
  localStorage.setItem('approvedEntriesCache', JSON.stringify(approvedEntriesCache));
}

// ----- Check Duplicate in Cache -----
function checkDuplicateInCache(flight, seat, date, name = null) {
  const flightUpper = flight.toUpperCase();
  const nameUpper = name ? name.toUpperCase() : '';
  const seatUpper = seat ? seat.toUpperCase() : '';
  
  if (flightUpper.startsWith('SQ')) {
    if (nameUpper) {
      for (const key in approvedEntriesCache) {
        const entry = approvedEntriesCache[key];
        
        if (entry.date !== date) continue;
        if (entry.flight !== flightUpper) continue;
        if (entry.name !== nameUpper) continue;
        
        return { 
          isDuplicate: true, 
          type: 'exact', 
          key: key,
          message: `${name} is already approved for flight ${flight} today`
        };
      }
    }
    return { isDuplicate: false };
  }
  
  const seatKey = `${date}_${flightUpper}_${seatUpper}`;
  if (approvedEntriesCache[seatKey]) {
    return { 
      isDuplicate: true, 
      type: 'seat', 
      key: seatKey,
      message: `Seat ${seat} is already approved for flight ${flight}`
    };
  }
  
  if (nameUpper) {
    const exactKey = `${date}_${flightUpper}_${seatUpper}_${nameUpper}`;
    if (approvedEntriesCache[exactKey]) {
      return { 
        isDuplicate: true, 
        type: 'exact', 
        key: exactKey,
        message: `${name} (${seat}) is already approved for flight ${flight}`
      };
    }
  }
  
  return { isDuplicate: false };
}

// ----- Check if flight is closed -----
async function isFlightClosed(flightNo, date) {
  if (!window.passengerDb) {
    return false;
  }
  
  try {
    const cacheKey = `${date}_${flightNo.toUpperCase()}_status`;
    if (flightStatusCache[cacheKey]) {
      return flightStatusCache[cacheKey];
    }
    
    const querySnapshot = await window.passengerDb
      .collection('flightinfo')
      .where('flightNo', '==', flightNo.toUpperCase())
      .where('date', '==', date)
      .limit(1)
      .get();
    
    if (querySnapshot.empty) {
      flightStatusCache[cacheKey] = false;
      return false;
    }
    
    const flightData = querySnapshot.docs[0].data();
    const isClosed = flightData.status === 'Closed' || 
                     flightData.status === 'Completed' || 
                     flightData.status === 'Departed' ||
                     flightData.status === 'Cancelled';
    
    flightStatusCache[cacheKey] = isClosed;
    setTimeout(() => {
      delete flightStatusCache[cacheKey];
    }, 5 * 60 * 1000);
    
    return isClosed;
    
  } catch (error) {
    console.error('Error checking flight status:', error);
    return false;
  }
}

// ----- Shift Management -----
function updateExistingEntriesDate() {
  if (!currentShiftType || !currentShiftDate) return;
  
  let data = JSON.parse(localStorage.getItem('codesData') || '[]');
  
  let updated = false;
  data = data.map(entry => {
    if (!entry.approved) {
      entry.date = currentShiftDate; // YYYY-MM-DD format
      entry.shift = currentShiftType;
      updated = true;
    }
    return entry;
  });
  
  if (updated) {
    localStorage.setItem('codesData', JSON.stringify(data));
    renderEntries();
  }
}

// ----- Clear input fields -----
function clearInputFields() {
  nameInput.value = '';
  pnrInput.value = '';
  flightInput.value = '';
  airlineSelect.value = '';
  seatInput.value = '';
  classInput.value = '';
  numPaxInput.value = '1';
  fqtvInput.value = '';
  serialInput.value = '';
  remarksInput.value = '';
  
  clearNotification.classList.add('show');
  setTimeout(() => {
    clearNotification.classList.remove('show');
  }, 3000);
}

// ----- Check if FQTV is required -----
function isFqtvRequired(classValue, fqtvValue) {
  return classValue && classValue.toUpperCase() === 'Y' && 
         (!fqtvValue || fqtvValue.trim() === '');
}

// ----- Optimized Duplicate Entry Check -----
function isDuplicateEntry(entry) {
  const data = JSON.parse(localStorage.getItem('codesData') || '[]');
  const flightUpper = entry.flight.toUpperCase();
  const nameUpper = entry.name.toUpperCase();
  const seatUpper = entry.seat.toUpperCase();
  
  if (flightUpper.startsWith('SQ')) {
    return data.some(existingEntry => 
      existingEntry.date === currentShiftDate && 
      existingEntry.flight.toUpperCase() === flightUpper && 
      existingEntry.name.toUpperCase() === nameUpper &&
      !existingEntry.approved
    );
  }
  
  return data.some(existingEntry => 
    existingEntry.date === currentShiftDate && 
    existingEntry.flight.toUpperCase() === flightUpper && 
    existingEntry.name.toUpperCase() === nameUpper &&
    existingEntry.seat.toUpperCase() === seatUpper &&
    !existingEntry.approved
  );
}

// ----- FAST Save Entry (Local only, NO Firebase) -----
function saveEntry(entry){
  if (!currentShiftType || currentShiftStatus !== 'open') {
    showAlert('No active shift or shift not open!', true);
    return;
  }
  
  // Ensure date is in YYYY-MM-DD format
  entry.date = currentShiftDate;
  entry.shift = currentShiftType;
  
  if (isDuplicateEntry(entry)) {
    console.log('Duplicate passenger detected, skipping save');
    showAlert(`${entry.name} is already entered for flight ${entry.flight}`, true);
    
    codeInput.value = '';
    codeInput.focus();
    setTimeout(clearInputFields, 2000);
    return;
  }
  
  let data = JSON.parse(localStorage.getItem('codesData')||'[]');
  data.push(entry);
  localStorage.setItem('codesData', JSON.stringify(data));
  
  if (!renderTimeout) {
    renderTimeout = setTimeout(() => {
      renderEntries();
      renderTimeout = null;
    }, 50);
  }

  // NO Firebase backup here - only save locally
  showAlert(`Entry saved locally!`);

  codeInput.value = '';
  codeInput.focus();
  setTimeout(clearInputFields, 2000);
}

// ----- Optimized Render Function -----
async function renderEntries() {
  if (isRendering) {
    clearTimeout(renderTimeout);
    renderTimeout = setTimeout(renderEntries, 100);
    return;
  }
  
  isRendering = true;
  
  try {
    const data = JSON.parse(localStorage.getItem('codesData') || '[]').filter(e => !e.approved);
    const dataString = JSON.stringify(data);
    
    if (dataString === lastRenderData && entriesList.children.length > 0) {
      isRendering = false;
      return;
    }
    
    lastRenderData = dataString;
    entriesCount.textContent = `${data.length} entries`;
    
    entriesList.innerHTML = '';
    
    const fragment = document.createDocumentFragment();
    
    for (const [i, e] of data.entries()) {
      const tr = document.createElement('tr');
      
      const isFqtvNeeded = isFqtvRequired(e.class, e.fqtv);
      
      if (isFqtvNeeded) {
        tr.classList.add('fqtv-required');
      }
      
      let fqtvDisplay = e.fqtv || '';
      if (isFqtvNeeded && !fqtvDisplay) {
        fqtvDisplay = '<span class="fqtv-warning">FQTV REQUIRED </span>';
      }
      
      const approveBtn = document.createElement('button');
      approveBtn.className = 'action-btn';
      approveBtn.innerHTML = '<i class="fas fa-check-circle"></i> Approve';
      approveBtn.onclick = (function(index) {
        return function(event) {
          event.stopPropagation();
          event.preventDefault();
          approveEntry(index);
        };
      })(i);
      
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'action-btn';
      deleteBtn.innerHTML = '<i class="fas fa-trash"></i> Delete';
      deleteBtn.onclick = (function(index) {
        return function(event) {
          event.stopPropagation();
          event.preventDefault();
          deleteEntry(index);
        };
      })(i);
      
      const actionsCell = document.createElement('td');
      actionsCell.appendChild(approveBtn);
      actionsCell.appendChild(deleteBtn);
      
      tr.innerHTML = `
        <td class="editable-cell" contenteditable="true" data-field="name">${escapeHtml(e.name)}</td>
        <td class="editable-cell" contenteditable="true" data-field="flight">${escapeHtml(e.flight)}</td>
        <td class="editable-cell" contenteditable="true" data-field="seat">${escapeHtml(e.seat)}</td>
        <td class="editable-cell" contenteditable="true" data-field="class">${escapeHtml(e.class || '')}</td>
        <td class="editable-cell" contenteditable="true" data-field="fqtv">${fqtvDisplay}</td>
        <td class="editable-cell" contenteditable="true" data-field="numPax">${e.numPax}</td>
        <td class="editable-cell" contenteditable="true" data-field="serial">${escapeHtml(e.serial)}</td>
        <td class="editable-cell" contenteditable="true" data-field="remarks">${escapeHtml(e.remarks)}</td>
        <td class="editable-cell" contenteditable="true" data-field="pnr">${escapeHtml(e.pnr)}</td>
        <td>${formatDateForDisplay(e.date)}</td>
        <td>${e.shift || currentShiftType || '-'}</td>
      `;
      
      tr.appendChild(actionsCell);
      fragment.appendChild(tr);
    }
    
    entriesList.appendChild(fragment);
    addAutoSaveListeners();
    
  } catch (error) {
    console.error('Error rendering entries:', error);
  } finally {
    isRendering = false;
  }
}

// ----- Escape HTML to prevent XSS -----
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

function addAutoSaveListeners() {
  const editableCells = document.querySelectorAll('.editable-cell');
  editableCells.forEach(cell => {
    cell.addEventListener('blur', function() {
      const row = this.closest('tr');
      const rowIndex = Array.from(row.parentNode.children).indexOf(row);
      saveEditedEntry(rowIndex);
    });
  });
}

function saveEditedEntry(rowIndex) {
  const data = JSON.parse(localStorage.getItem('codesData')||'[]');
  const entry = data[rowIndex];
  
  if (!entry) return;
  
  const rows = entriesList.querySelectorAll('tr');
  const targetRow = rows[rowIndex];
  
  if (!targetRow) return;
  
  entry.name = targetRow.cells[0].textContent.trim();
  entry.flight = targetRow.cells[1].textContent.trim();
  entry.seat = targetRow.cells[2].textContent.trim();
  entry.class = targetRow.cells[3].textContent.trim();
  
  let fqtvValue = targetRow.cells[4].textContent.trim();
  fqtvValue = fqtvValue.replace('FQTV REQUIRED', '').trim();
  entry.fqtv = fqtvValue;
  
  entry.numPax = Number(targetRow.cells[5].textContent.trim()) || 1;
  entry.serial = targetRow.cells[6].textContent.trim();
  entry.remarks = targetRow.cells[7].textContent.trim();
  entry.pnr = targetRow.cells[8].textContent.trim();
  
  localStorage.setItem('codesData', JSON.stringify(data));
}

// ----- ULTRA-FAST Approve Entry (Save to Firebase only when approving) -----
function approveEntry(index) {
  if (!currentShiftType || currentShiftStatus !== 'open') {
    showAlert('No active shift or shift not open!', true);
    return;
  }
  
  if (isApproving) {
    return;
  }
  
  isApproving = true;
  
  try {
    let data = JSON.parse(localStorage.getItem('codesData')||'[]');
    const entry = data[index];
    
    if (!entry) {
      isApproving = false;
      return;
    }

    // Check if FQTV is required but not provided
    if (isFqtvRequired(entry.class, entry.fqtv)) {
      showAlert(`Cannot approve: Economy Class passenger requires FQTV card or primary guest seat`, true);
      isApproving = false;
      return;
    }

    const flightUpper = entry.flight.toUpperCase();
    const nameUpper = entry.name.toUpperCase();
    const seatUpper = entry.seat.toUpperCase();
    
    // 1. FAST LOCAL DUPLICATE CHECK (synchronous)
    const duplicateCheck = checkDuplicateInCache(entry.flight, entry.seat, currentShiftDate, entry.name);
    if (duplicateCheck.isDuplicate) {
      showAlert(duplicateCheck.message, true);
      isApproving = false;
      
      // Mark this entry as duplicate and remove it
      data.splice(index, 1);
      localStorage.setItem('codesData', JSON.stringify(data));
      renderEntries();
      return;
    }
    
    // ----- Process FQTV with tier level -----
    let processedFqtv = '';
    if (entry.fqtv && entry.fqtv.trim() !== '') {
      const fqtvValue = entry.fqtv.trim();
      
      const baseFqtv = fqtvValue.replace(/\/\s*(Platinum|Gold|Silver|Emerald|Sapphire|Ruby|G|S|GOLD|SILVER|PLATINUM)\s*$/i, '').trim();
      
      const tierLevel = processFqtvTier(baseFqtv, entry.flight);
      
      if (tierLevel) {
        processedFqtv = `${baseFqtv}/${tierLevel}`;
      } else {
        processedFqtv = baseFqtv;
      }
    }

    const approvedEntry = {
      airline: airlines[entry.airline] || entry.airline,
      approved: true,
      checkinTime: "",
      date: currentShiftDate, // This is in YYYY-MM-DD format
      flightNo: flightUpper,
      fqtv: processedFqtv,
      name: entry.name,
      numPax: Number(entry.numPax) || 1,
      remarks: entry.remarks || "-",
      seatNo: seatUpper,
      class: entry.class || "-",
      pnr: entry.pnr,
      serial: entry.serial || "-",
      shift: currentShiftType,
      timeAdded: getCurrentTime(),
      approvedBy: userData ? userData.name : 'Unknown',
      approvedAt: new Date().toISOString(),
      localId: `local_${Date.now()}_${Math.random().toString(36).substr(2, 9)}` // Unique ID for tracking
    };

    // Ensure date is in YYYY-MM-DD format (double-check)
    if (approvedEntry.date && approvedEntry.date.includes(',')) {
      approvedEntry.date = parseDateToYYYYMMDD(approvedEntry.date);
    }
    
    console.log("Approved entry with date:", approvedEntry.date); // Debug log

    // 2. CREATE DOCUMENT NAME
    let docName;
    const timestamp = Date.now();
    const randomSuffix = Math.random().toString(36).substring(2, 8);
    
    if (flightUpper.startsWith('SQ')) {
      const cleanName = nameUpper.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 30);
      docName = `${approvedEntry.date}_${flightUpper}_${cleanName}_${timestamp}_${randomSuffix}`;
    } else {
      docName = `${approvedEntry.date}_${flightUpper}_${seatUpper}_${timestamp}`;
    }
    
    // 3. IMMEDIATELY UPDATE LOCAL STORAGE AND UI (NO WAITING)
    
    // Save to local cache IMMEDIATELY (use the formatted date)
    saveToApprovedCache(entry.flight, entry.seat, approvedEntry.date, entry.name, docName);
    
    // Store the approved entry in localStorage with sync status
    let approvedLocalData = JSON.parse(localStorage.getItem('approvedLocalData') || '[]');
    approvedLocalData.push({
      ...approvedEntry,
      docName: docName,
      synced: false,
      syncedAt: null
    });
    localStorage.setItem('approvedLocalData', JSON.stringify(approvedLocalData));
    
    // Remove from pending entries IMMEDIATELY
    data.splice(index, 1);
    localStorage.setItem('codesData', JSON.stringify(data));
    
    // Update UI IMMEDIATELY
    renderEntries();
    
    // Show success message IMMEDIATELY
    showAlert(`Entry approved successfully!`);
    
    // 4. SAVE TO FIREBASE IN BACKGROUND (NON-BLOCKING) - ONLY HERE
    if (window.passengerDb) {
      // Queue for background save
      addToBackgroundSaveQueue(approvedEntry, docName, approvedEntry.localId);
    } else {
      // If Firebase not available, mark for retry later
      showAlert("Approved locally, will sync to server when connection available", true);
    }
    
    // Optional: Check flight status in background (non-blocking)
    isFlightClosed(entry.flight, approvedEntry.date).then(isClosed => {
      if (isClosed) {
        console.log(`Flight ${entry.flight} is closed, but entry was already approved`);
      }
    });
    
  } catch (e) {
    console.error('Error in approval:', e);
    showAlert('Error: ' + e.message, true);
  } finally {
    isApproving = false;
  }
}

// ----- Fast Single-Click DELETE Entry -----
function deleteEntry(index) {
  if (isApproving) {
    return;
  }
  
  let data = JSON.parse(localStorage.getItem('codesData')||'[]');
  
  if (index >= 0 && index < data.length) {
    data.splice(index, 1);
    localStorage.setItem('codesData', JSON.stringify(data));
    renderEntries();
    showAlert('Entry deleted successfully!');
  }
}

// ----- Check for unsynced items on page load -----
function checkAndRetryUnsyncedItems() {
  try {
    const approvedLocalData = JSON.parse(localStorage.getItem('approvedLocalData') || '[]');
    const unsyncedItems = approvedLocalData.filter(item => !item.synced);
    
    if (unsyncedItems.length > 0 && window.passengerDb) {
      console.log(`Found ${unsyncedItems.length} unsynced items, retrying...`);
      
      unsyncedItems.forEach(item => {
        addToBackgroundSaveQueue(item, item.docName, item.localId);
      });
      
      showAlert(`Found ${unsyncedItems.length} pending approvals, syncing...`, false, true);
    }
  } catch (error) {
    console.error('Error checking unsynced items:', error);
  }
}

// ----- Parse code (with universal FQTV detection and SQ flight handling) -----
function parseCode(){
  const code = codeInput.value.trim().toUpperCase();
  if(!code) return;
  const parts = code.split(/\s+/);
  
  console.log("DEBUG: Parsing barcode tokens:", parts);

  const idxMLE = code.indexOf('MLE');
  let name='', pnr='';
  if(idxMLE!==-1){
    let fullNamePart = code.substring(0,idxMLE).trim();
    if(fullNamePart.length>8){
      name = fullNamePart.substring(2, fullNamePart.length-7).trim();
      pnr = fullNamePart.substring(fullNamePart.length-7).trim();
    }
  }

  let flightNo=''; let flightTokenIndex=-1;
  for(let i=0;i<parts.length;i++){
    if(parts[i].includes('MLE')){
      flightTokenIndex=i;
      const mleToken = parts[i];
      flightNo = mleToken.slice(-2) + (parts[i+1]||'').slice(0,4);
      break;
    }
  }

  if(flightNo.length>=2){
    const iata = flightNo.slice(0,2);
    airlineSelect.value = airlines[iata]?iata:'';
  } else airlineSelect.value='';

  let seatNo='';
  let seatClass='';
  if(flightTokenIndex!==-1 && parts[flightTokenIndex+2]){
    let seatToken = parts[flightTokenIndex+2];
    if(seatToken.length>9){
      if (seatToken.length >= 4) {
        seatClass = seatToken.charAt(3);
      }
      
      if (seatToken.length >= 8) {
        const rowPart = seatToken.substring(4, 7);
        const seatLetter = seatToken.charAt(7);
        const rowNumber = parseInt(rowPart, 10).toString();
        seatNo = rowNumber + seatLetter;
      }
    }
  }

  let fqtv = null;
  let fqtvTierCode = '';
  let hasNoFqtv = false;
  
  // Get ALL airline codes from the airlines object
  const allAirlineCodes = Object.keys(airlines);
  
  // Define tier names to look for (with Y prefix and without)
  const tierNames = ['SAPPHIRE', 'EMERALD', 'RUBY', 'PLATINUM', 'GOLD', 'SILVER'];
  
  console.log("DEBUG: All airline codes:", allAirlineCodes);
  
  // SIMPLE FQTV DETECTION: Scan forward through parts
  for (let i = 0; i < parts.length; i++) {
    const currentToken = parts[i].toUpperCase();
    
    // Check if token is an airline code
    if (allAirlineCodes.includes(currentToken)) {
      console.log(`DEBUG: Found airline code "${currentToken}" at position ${i}`);
      
      // Check if next token exists and is a number
      if (i + 1 < parts.length) {
        const nextToken = parts[i + 1];
        console.log(`DEBUG: Next token after "${currentToken}": "${nextToken}"`);
        
        // Check if next token is a number (FQTV number)
        if (/^\d+$/.test(nextToken)) {
          fqtv = currentToken + ' ' + nextToken;
          console.log(`DEBUG: FOUND FQTV: ${fqtv}`);
          
          // Check for tier name in the token after the number
          if (i + 2 < parts.length) {
            const tierToken = parts[i + 2].toUpperCase();
            console.log(`DEBUG: Tier token: "${tierToken}"`);
            
            // Check for tier names (including Y prefix like YSAPPHIRE)
            if (tierToken.includes('SAPPHIRE')) {
              fqtvTierCode = 'n2';
              console.log('DEBUG: Found Sapphire tier');
            } else if (tierToken.includes('EMERALD')) {
              fqtvTierCode = 'n3';
              console.log('DEBUG: Found Emerald tier');
            } else if (tierToken.includes('RUBY')) {
              fqtvTierCode = 'n1';
              console.log('DEBUG: Found Ruby tier');
            } else if (tierToken.includes('PLATINUM')) {
              fqtvTierCode = 'n3';
              console.log('DEBUG: Found Platinum tier');
            } else if (tierToken.includes('GOLD')) {
              fqtvTierCode = 'n2';
              console.log('DEBUG: Found Gold tier');
            } else if (tierToken.includes('SILVER')) {
              fqtvTierCode = 'n1';
              console.log('DEBUG: Found Silver tier');
            } else if (tierToken === 'N0') {
              hasNoFqtv = true;
              fqtv = '';
              console.log('DEBUG: Found N0 (no FQTV)');
            } else if (tierToken === 'N1' || tierToken === 'N2' || tierToken === 'N3') {
              fqtvTierCode = tierToken.toLowerCase();
              console.log(`DEBUG: Found N-tier: ${tierToken}`);
            }
          }
          break;
        }
      }
    }
    
    // Also check for combined airline+number pattern (e.g., JL206645985)
    for (const airlineCode of allAirlineCodes) {
      if (currentToken.startsWith(airlineCode) && currentToken.length > 2 && /^\d+$/.test(currentToken.substring(2))) {
        fqtv = airlineCode + ' ' + currentToken.substring(2);
        console.log(`DEBUG: Found combined FQTV: ${fqtv}`);
        
        // Check for tier in next token
        if (i + 1 < parts.length) {
          const tierToken = parts[i + 1].toUpperCase();
          // Same tier detection logic as above
          if (tierToken.includes('SAPPHIRE')) fqtvTierCode = 'n2';
          else if (tierToken.includes('EMERALD')) fqtvTierCode = 'n3';
          else if (tierToken.includes('RUBY')) fqtvTierCode = 'n1';
          else if (tierToken.includes('PLATINUM')) fqtvTierCode = 'n3';
          else if (tierToken.includes('GOLD')) fqtvTierCode = 'n2';
          else if (tierToken.includes('SILVER')) fqtvTierCode = 'n1';
          else if (tierToken === 'N0') { hasNoFqtv = true; fqtv = ''; }
          else if (tierToken === 'N1' || tierToken === 'N2' || tierToken === 'N3') fqtvTierCode = tierToken.toLowerCase();
        }
        break;
      }
    }
    if (fqtv) break;
  }

  // Apply formatting
  if (!hasNoFqtv && fqtv) {
    // Clean up the FQTV
    fqtv = fqtv.trim();
    
    // Apply dash formatting for ANY airline code
    if (fqtv) {
      // Extract the airline code (first 2 characters)
      const airlineCode = fqtv.substring(0, 2).toUpperCase();
      
      // Check if it's a valid airline code
      if (allAirlineCodes.includes(airlineCode)) {
        // Replace space with dash: "JL 206645985" -> "JL-206645985"
        fqtv = fqtv.replace(/^([A-Z0-9]{2})\s+/, '$1-');
      }
    }
    
    // Apply tier level if found
    if (fqtv && fqtvTierCode) {
      // Extract airline code from flight for comparison
      const flightAirlineCode = flightNo.slice(0, 2).toUpperCase();
      let fqtvAirlineCode = '';
      
      // Try to extract airline code from FQTV
      const fqtvUpper = fqtv.toUpperCase();
      
      // Pattern 1: Two letters followed by dash/space
      const dashMatch = fqtvUpper.match(/^([A-Z0-9]{2})[- ]/);
      if (dashMatch) {
        fqtvAirlineCode = dashMatch[1];
      } else {
        // Pattern 2: First two letters
        fqtvAirlineCode = fqtvUpper.substring(0, 2);
      }
      
      console.log(`DEBUG: Flight=${flightNo}, Flight Airline=${flightAirlineCode}, FQTV=${fqtv}, FQTV Airline=${fqtvAirlineCode}, Tier Code=${fqtvTierCode}`);
      
      // Determine which tier mapping to use
      let tierName;
      if (fqtvAirlineCode && flightAirlineCode && 
          fqtvAirlineCode.toUpperCase() === flightAirlineCode.toUpperCase()) {
        // Same airline
        tierName = fqtvTierMappings.same[fqtvTierCode] || '';
      } else {
        // Different airline
        tierName = fqtvTierMappings.different[fqtvTierCode] || '';
      }
      
      if (tierName) {
        // Remove any trailing tier code or tier name before adding the standard tier name
        fqtv = fqtv.replace(/\/\s*(Sapphire|Emerald|Ruby|Platinum|Gold|Silver|SAPPHIRE|EMERALD|RUBY|PLATINUM|GOLD|SILVER)\s*$/i, '');
        fqtv = fqtv.replace(/[Nn][123]\s*$/, '').trim();
        fqtv = `${fqtv}/${tierName}`;
      }
    }
  }

  const lastTwo = code.slice(-2);
  // Handle Y1/Y2 suffix for BA/MH
  if (!hasNoFqtv && (flightNo.startsWith('BA') || flightNo.startsWith('MH')) && fqtv) {
    if (lastTwo === 'Y1') {
      if (!fqtv.includes('/')) {
        fqtv += '/G';
      } else if (!fqtv.includes('/G')) {
        fqtv = fqtv.replace(/\/[^\/]+$/, '/G');
      }
    } else if (lastTwo === 'Y2') {
      if (!fqtv.includes('/')) {
        fqtv += '/S';
      } else if (!fqtv.includes('/S')) {
        fqtv = fqtv.replace(/\/[^\/]+$/, '/S');
      }
    }
  } else if (flightNo.startsWith('OS')) {
    // Special handling for Austrian Airlines
    const lastIndex = parts.length - 1;
    const fourthLast = parts[lastIndex - 3] || '';
    const thirdLast = parts[lastIndex - 2] || '';
    const fourthLastToken = fourthLast.trim();
    const thirdLastToken = thirdLast.trim();
    
    if (fourthLastToken.length === 2 && thirdLastToken.length > 4) {
      if (!fqtv) {
        fqtv = (fourthLastToken + ' ' + thirdLastToken).trim();
      }
    }
  }

  // SPECIAL HANDLING FOR SQ FLIGHTS
  if (flightNo.startsWith('SQ')) {
    // Clear seat number for SQ flights
    seatNo = '';
    // Also clear PNR for SQ flights
    pnr = '';
  }

  nameInput.value = name;
  pnrInput.value = pnr;
  flightInput.value = flightNo;
  seatInput.value = seatNo;
  classInput.value = seatClass;
  // Set FQTV to empty if n0 was found
  fqtvInput.value = hasNoFqtv ? '' : (fqtv || '');
  serialInput.value = '';
  remarksInput.value = '';
  numPaxInput.value = 1;
}

// ----- Barcode Scanner Detection -----
let scannerTimer;
let lastValue = '';
let isScannerActive = false;
let isProcessing = false;

function handleScannerInput() {
  if (isProcessing) return;
  
  const currentValue = codeInput.value;
  
  if (currentValue.length > lastValue.length + 5) {
    isScannerActive = true;
    scannerIndicator.classList.add('show');
    
    clearTimeout(scannerTimer);
    scannerTimer = setTimeout(() => {
      processScannerInput();
    }, 100);
  } 
  else if (currentValue !== lastValue) {
    if (isScannerActive) {
      isScannerActive = false;
      scannerIndicator.classList.remove('show');
    }
    
    clearTimeout(scannerTimer);
    scannerTimer = setTimeout(() => {
      processManualInput();
    }, 800);
  }
  
  lastValue = currentValue;
}

function processScannerInput() {
  if (isProcessing) return;
  isProcessing = true;
  
  scannerIndicator.classList.remove('show');
  isScannerActive = false;
  
  parseCode();
  const entry = {
    date: currentShiftDate, // YYYY-MM-DD format
    user: userDisplay.textContent,
    shift: currentShiftType,
    code: codeInput.value,
    name: nameInput.value,
    pnr: pnrInput.value,
    flight: flightInput.value,
    airline: airlineSelect.value,
    seat: seatInput.value,
    class: classInput.value,
    serial: serialInput.value,
    remarks: remarksInput.value,
    fqtv: fqtvInput.value,
    numPax: Number(numPaxInput.value)||1,
    approved: false
  };
  saveEntry(entry);
  
  setTimeout(() => {
    isProcessing = false;
  }, 1000);
}

function processManualInput() {
  if (isProcessing) return;
  isProcessing = true;
  
  parseCode();
  const entry = {
    date: currentShiftDate, // YYYY-MM-DD format
    user: userDisplay.textContent,
    shift: currentShiftType,
    code: codeInput.value,
    name: nameInput.value,
    pnr: pnrInput.value,
    flight: flightInput.value,
    airline: airlineSelect.value,
    seat: seatInput.value,
    class: classInput.value,
    serial: serialInput.value,
    remarks: remarksInput.value,
    fqtv: fqtvInput.value,
    numPax: Number(numPaxInput.value)||1,
    approved: false
  };
  saveEntry(entry);
  
  setTimeout(() => {
    isProcessing = false;
  }, 1000);
}

function handleFieldExit() {
  if (isProcessing) return;
  
  const code = codeInput.value.trim();
  if (code) {
    parseCode();
    if (nameInput.value && flightInput.value) {
      isProcessing = true;
      const entry = {
        date: currentShiftDate, // YYYY-MM-DD format
        user: userDisplay.textContent,
        shift: currentShiftType,
        code: codeInput.value,
        name: nameInput.value,
        pnr: pnrInput.value,
        flight: flightInput.value,
        airline: airlineSelect.value,
        seat: seatInput.value,
        class: classInput.value,
        serial: serialInput.value,
        remarks: remarksInput.value,
        fqtv: fqtvInput.value,
        numPax: Number(numPaxInput.value)||1,
        approved: false
      };
      saveEntry(entry);
      
      setTimeout(() => {
        isProcessing = false;
      }, 1000);
    }
  }
}

manualSaveBtn.addEventListener('click', ()=>{
  if (isProcessing) return;
  isProcessing = true;
  
  parseCode();
  const entry = {
    date: currentShiftDate, // YYYY-MM-DD format
    user: userDisplay.textContent,
    shift: currentShiftType,
    code: codeInput.value,
    name: nameInput.value,
    pnr: pnrInput.value,
    flight: flightInput.value,
    airline: airlineSelect.value,
    seat: seatInput.value,
    class: classInput.value,
    serial: serialInput.value,
    remarks: remarksInput.value,
    fqtv: fqtvInput.value,
    numPax: Number(numPaxInput.value)||1,
    approved: false
  };
  saveEntry(entry);
  
  setTimeout(() => {
    isProcessing = false;
  }, 1000);
});

// ----- Initialize -----
document.addEventListener('DOMContentLoaded', function() {
  // Convert existing data to YYYY-MM-DD format
  convertExistingDataToYYYYMMDD();
  
  // Load approved entries cache
  loadApprovedEntriesCache();
  
  // Try to load shift from localStorage first
  const loadedFromCache = loadCurrentShiftFromLocalStorage();
  
  // Setup refresh button
  refreshShiftBtn.addEventListener('click', fetchCurrentOpenShift);
  
  // Check for unsynced items
  checkAndRetryUnsyncedItems();
  
  // If not loaded from cache, fetch from Firebase
  if (!loadedFromCache) {
    showNoShiftMessage();
    // Automatically try to fetch shift on page load
    setTimeout(() => {
      fetchCurrentOpenShift();
    }, 500);
  }
  
  // Optimized event listeners
  codeInput.addEventListener('input', handleScannerInput);
  
  codeInput.addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
      e.preventDefault();
      clearTimeout(scannerTimer);
      if (isScannerActive) {
        processScannerInput();
      } else {
        processManualInput();
      }
    }
  });
  
  codeInput.addEventListener('blur', handleFieldExit);
  
  renderEntries();
});
</script>
</body>
</html>
